<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>227. Basic Calculator II</title>
      <link href="/2020/08/09/leetecode/227-Basic-Calculator-II/"/>
      <url>/2020/08/09/leetecode/227-Basic-Calculator-II/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个字符串，是一个算术运算的表达式。要你求出这个算术运算表达式的结果。<br>例子如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: &quot;3+2*2&quot;</span><br><span class="line">Output: 7</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: &quot; 3/2 &quot;</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line">Input: &quot; 3+5 / 2 &quot;</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><p>其中除法除不尽，就去小数点前面的整数。</p><a id="more"></a><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>根据题目的要求，主要是为了区分’+’, ‘-‘, ‘*‘, ‘/‘的算术优先级。我们可以用一个操作数栈来保存数字和当前运算的结果，用一个运算符栈来保存运算符。顺序扫描字符串，如果碰到空格就忽略。当碰到一个操作符时候，把这个运算符前面的操作数压入操作数栈。扫描到操作符做后续操作分两种情况。<br><br>1.如果当前扫描到的操作符是’+’或’-‘时，它与’+’和’-‘的运算优先级一样，比’*‘和’/‘的优先级低，所以可以先求出之前扫描得到的结果。既每次弹出操作符栈，然后在操作数栈中弹出两个数进行运算，每次得到的结果压入到操作数栈中继续后面的操作，直到操作符栈为空。<br><br>2.如果当前扫描到的操作符是’*‘或’/‘时,这种操作数优先级高，只有当操作符栈顶同样为’*‘或’/‘时，优先级一样，才做如上述1所述的操作，弹出操作数和操作符进行运算。否则结束这次操作，继续扫描。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numStack;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; operationStack;</span><br><span class="line"><span class="keyword">int</span> startIndex = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(s[i] == <span class="string">' '</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(startIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">num = stoi(s.substr(startIndex, i - startIndex));</span><br><span class="line">startIndex = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(startIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">startIndex = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(startIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">num = stoi(s.substr(startIndex, i - startIndex));</span><br><span class="line">startIndex = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">numStack.push_back(num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(s[i] == <span class="string">'+'</span> || s[i] == <span class="string">'-'</span>) &#123;</span><br><span class="line"><span class="keyword">while</span>(!operationStack.empty()) &#123;</span><br><span class="line"><span class="keyword">char</span> op = operationStack.back();</span><br><span class="line">operationStack.pop_back();</span><br><span class="line"><span class="keyword">int</span> b = numStack.back();</span><br><span class="line">numStack.pop_back();</span><br><span class="line"><span class="keyword">int</span> a = numStack.back();</span><br><span class="line">numStack.pop_back();</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(op == <span class="string">'+'</span>) &#123;</span><br><span class="line">result = a + b;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">'-'</span>) &#123;</span><br><span class="line">result = a - b;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">'*'</span>) &#123;</span><br><span class="line">result = a * b;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">result = a / b;</span><br><span class="line">&#125;</span><br><span class="line">numStack.push_back(result);</span><br><span class="line">&#125; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(!operationStack.empty()) &#123;</span><br><span class="line"><span class="keyword">char</span> op = operationStack.back();</span><br><span class="line"><span class="keyword">if</span>(op == <span class="string">'+'</span> || op == <span class="string">'-'</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">operationStack.pop_back();</span><br><span class="line"><span class="keyword">int</span> b = numStack.back();</span><br><span class="line">numStack.pop_back();</span><br><span class="line"><span class="keyword">int</span> a = numStack.back();</span><br><span class="line">numStack.pop_back();</span><br><span class="line"><span class="keyword">int</span> result = op == <span class="string">'*'</span> ? a * b : a / b;</span><br><span class="line">numStack.push_back(result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">operationStack.push_back(s[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(startIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">num = stoi(s.substr(startIndex, s.length() - startIndex));</span><br><span class="line">&#125;</span><br><span class="line">numStack.push_back(num);</span><br><span class="line"><span class="keyword">while</span>(!operationStack.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> a = numStack.back();</span><br><span class="line">numStack.pop_back();</span><br><span class="line"><span class="keyword">int</span> b = numStack.back();</span><br><span class="line">numStack.pop_back();</span><br><span class="line"><span class="keyword">char</span> op = operationStack.back();</span><br><span class="line">operationStack.pop_back();</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(op == <span class="string">'+'</span>) &#123;</span><br><span class="line">result = a + b;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">'-'</span>) &#123;</span><br><span class="line">result = b - a;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">'*'</span>) &#123;</span><br><span class="line">result = a * b;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">result = b / a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">numStack.push_back(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> numStack.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>454. 4Sum II</title>
      <link href="/2020/08/09/leetecode/454-4Sum-II/"/>
      <url>/2020/08/09/leetecode/454-4Sum-II/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定四组数，在这四组数里面分别取出一个数，使得这4个数的和为0。要你求一共有多少种这样的取法。</p><a id="more"></a><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>用一个hash存储前2组数的和，key为和，value为+1，既为这种和有多少种情况。然后枚举后2组数的和，求其相反数，看是否在hash中存储，将这些情况累加在一起既为结果。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; C, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; D)</span> </span>&#123;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; C.size(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; D.size(); j++) &#123;</span><br><span class="line">count[(C[i] + D[j])] += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B.size(); j++) &#123;</span><br><span class="line">result += count[-(A[i]+B[j])];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>518. Coin Change 2</title>
      <link href="/2020/08/08/leetecode/518-Coin-Change-2/"/>
      <url>/2020/08/08/leetecode/518-Coin-Change-2/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一批硬币和一个金额。要求出硬币有多少种组合方式可以兑换这个金额。其中假定没种硬币不限量。</p><a id="more"></a><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>动态规划，用dp[k][i]表示金额i,使用前k种硬币，一共有多少种的组合方法。<br>状态转移方程dp[k][i] = dp[k][i] + dp[k - 1][i - coins[k]]; 初始状态dp[0][0] = 1。用滚动数组，将dp二维降到一维。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(amount + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = coins.begin(); iter != coins.end(); iter++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = *iter; i &lt;= amount; i++) &#123;</span><br><span class="line">dp[i] += dp[i - *iter];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>322. Coin Change</title>
      <link href="/2020/08/08/leetecode/322-Coin-Change/"/>
      <url>/2020/08/08/leetecode/322-Coin-Change/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一批硬币，和一个金额。要你求通过这些硬币，来兑换这个金额，求出使用最少硬币数来兑换这个金额。其中硬币可以重复使用。如果没有兑换方式，则输出-1.<br>兑换方法如下例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: coins = [1, 2, 5], amount = 11</span><br><span class="line">Output: 3 </span><br><span class="line">Explanation: 11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: coins = [2], amount = 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>类似于0/1背包问题。动态规划解决。用dp[k][i]表示金额i用前k种硬币，使用最少硬币的数量。<br>状态方程为dp[k][i] = min(dp[k-1][i], dp[k-1][i - coins[k]] + 1). dp[k][i]的初始状态，用各个硬币的值来初始。用滚动数组可以把二维存储降到一维。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line"><span class="comment">//sort(coins.begin(), coins.end());</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(amount + <span class="number">1</span>, amount + <span class="number">1</span>);</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = coins.begin(); iter != coins.end(); iter++) &#123;</span><br><span class="line"><span class="keyword">if</span>(*iter &lt;= amount) &#123;</span><br><span class="line">dp[*iter] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = coins.begin(); iter != coins.end(); iter++) &#123;</span><br><span class="line"><span class="keyword">int</span> remain = i - *iter;</span><br><span class="line"><span class="keyword">if</span>(remain &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">dp[i] = min(dp[remain] + <span class="number">1</span>, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[amount] &gt;= amount + <span class="number">1</span> ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>445. Add Two Numbers II</title>
      <link href="/2020/08/08/leetecode/445-Add-Two-Numbers-II/"/>
      <url>/2020/08/08/leetecode/445-Add-Two-Numbers-II/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定两个链表，链表的每个节点分别代表数字每位的数值。既一个链表表示一个数字。要求两个链表表示的数字相加的和，和也用链表来存储。<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>简单的十进制加法运算，从个位开始加，一直加到最高位。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;ListNode*&gt; vec1;</span><br><span class="line"><span class="built_in">vector</span>&lt;ListNode*&gt; vec2;</span><br><span class="line">push(l1, vec1);</span><br><span class="line">push(l2, vec2);</span><br><span class="line">ListNode* head;</span><br><span class="line">ListNode* next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> carrier = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!vec1.empty() || !vec2.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> a1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!vec1.empty()) &#123;</span><br><span class="line">a1 = vec1.back()-&gt;val;</span><br><span class="line">vec1.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!vec2.empty()) &#123;</span><br><span class="line">a2 = vec2.back()-&gt;val;</span><br><span class="line">vec2.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> result = a1 + a2 + carrier;</span><br><span class="line">carrier = result / <span class="number">10</span>;</span><br><span class="line">result = result % <span class="number">10</span>;</span><br><span class="line">head = <span class="keyword">new</span> ListNode(result, next);</span><br><span class="line">next = head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(carrier != <span class="number">0</span>) &#123;</span><br><span class="line">head = <span class="keyword">new</span> ListNode(carrier, next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(ListNode* l, <span class="built_in">vector</span>&lt;ListNode*&gt; &amp;vec)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(l != <span class="literal">NULL</span>) &#123;</span><br><span class="line">vec.push_back(l);</span><br><span class="line">l = l-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>19. Remove Nth Node From End of List</title>
      <link href="/2020/08/08/leetecode/19-Remove-Nth-Node-From-End-of-List/"/>
      <url>/2020/08/08/leetecode/19-Remove-Nth-Node-From-End-of-List/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个链表，要求删除倒数第n个节点。其中保证链表长度一定大于等于n，既一定存在倒数第n个节点。</p><a id="more"></a><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>用一个指针先走n步，然后再用另一个指针指向head头部。两个指针同步往前走。如果前一个指针到达链表尾部。则后一个指针指向的就是倒数第n个节点。最后做链表删除操作的时候，需要对删除节点是头节点和非头节点进行分情况的处理。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">ListNode* prev = head;</span><br><span class="line">ListNode* cur = head;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; cur != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(cur != <span class="literal">NULL</span> &amp;&amp; cur-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">prev = prev-&gt;next;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cur == <span class="literal">NULL</span>) &#123;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> prev;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cur = prev-&gt;next;</span><br><span class="line">prev-&gt;next = prev-&gt;next-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> cur;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>142. Linked List Cycle II</title>
      <link href="/2020/08/08/leetecode/142-Linked-List-Cycle-II/"/>
      <url>/2020/08/08/leetecode/142-Linked-List-Cycle-II/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个链表，要你判断这个链表是否包含环。如果未包含，则输出NULL。如果包含，则输出这个环的进入节点。如果快指针和慢指针能够重合，则说明快指针比慢指针多跑了一圈环。则我们用a表示从起始节点到环的进入点的长度，b表示进入点到快慢指针重合点的长度。a + b为慢指针走过的路程，则快指针走过的路程为2 <em> (a + b)。快指针走的路程为起始节点到环进入点的长度加上环的长度，再加上进入点到重合点的长度。我们用c表示重合点顺时针到进入点的长度。则 2 </em> (a + b) = a + (b + c) + b, 得到c = a。既重合点到环进入点的位置长度就是起点到进入点的长度。所以当快慢指针都重合的时候，然慢指针继续走，同时另一个指针cur指向链表头，与慢指针同步走。慢指针向前一步，cur指针也向前一步。当慢指针与cur指针重合时候，此时指向的节点为环的进入节点。</p><a id="more"></a><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>确定一个链表是否有环，可以用快慢指针来实现。如果快指针能和慢指针重合，则说明有环。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">ListNode *slowPointer = head-&gt;next;</span><br><span class="line">ListNode *fastPointer = head-&gt;next-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(slowPointer != fastPointer) &#123;</span><br><span class="line"><span class="keyword">if</span>(fastPointer == <span class="literal">NULL</span> || fastPointer-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">slowPointer = slowPointer-&gt;next;</span><br><span class="line">fastPointer = fastPointer-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">ListNode *curPointer = head;</span><br><span class="line"><span class="keyword">while</span>(curPointer != fastPointer) &#123;</span><br><span class="line">curPointer = curPointer-&gt;next;</span><br><span class="line">fastPointer = fastPointer-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> curPointer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>151. Reverse Words in a String</title>
      <link href="/2020/08/08/leetecode/151-Reverse-Words-in-a-String/"/>
      <url>/2020/08/08/leetecode/151-Reverse-Words-in-a-String/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个字符串，需要你输出它的反序字符串。反序字符串由一个个完整的单词组成。<br>如下面的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;the sky is blue&quot;</span><br><span class="line">Output: &quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;  hello world!  &quot;</span><br><span class="line">Output: &quot;world! hello&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;a good   example&quot;</span><br><span class="line">Output: &quot;example good a&quot;</span><br></pre></td></tr></table></figure><p>输出反序字符串，需要将每个单词前后的多于的连续空格给去除掉，并且将字符串首尾的空格给去除掉。</p><a id="more"></a><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>扫描字符串，确定每个单词的边界。遇到非空格字符时，判断单词起始点是否被记录，如果未被记录，则记录存储下来。若以记录，则忽略继续扫描。如果遇到的是空字符，则判断是否已经确定了单词的起始点，如果确定了，则将起始点到前一个位置组成的单词压入栈，然后重置单词起始位置为未确定。如果未确定，则忽略继续扫描。将每个单词压入栈中。然后弹栈一个个单词输出。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line"><span class="keyword">int</span> startIndex = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">string</span> rev = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(s[i] != <span class="string">' '</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(startIndex == <span class="number">-1</span>) &#123;</span><br><span class="line">startIndex = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(startIndex != <span class="number">-1</span>) &#123;</span><br><span class="line">result.push_back(s.substr(startIndex, i - startIndex));</span><br><span class="line">startIndex = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">if</span>(startIndex != <span class="number">-1</span>) &#123;</span><br><span class="line">            result.push_back(s.substr(startIndex, s.size() - startIndex));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = result.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">rev += result[i];</span><br><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">rev += <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>143. Reorder List</title>
      <link href="/2020/08/08/leetecode/143-Reorder-List/"/>
      <url>/2020/08/08/leetecode/143-Reorder-List/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个链表，需要你重新安排链表的顺序。顺序规则如下面所述。<br>原始链表为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list L: L0→L1→…→Ln-1→Ln</span><br></pre></td></tr></table></figure></p><p>重新排序的链表为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L0→Ln→L1→Ln-1→L2→Ln-2→…</span><br></pre></td></tr></table></figure></p><p>也既首先输出第一个节点L0,然后是最后一个节点Ln;再输出节点L1,然后是倒数第二个节点Ln-1。如此前后交替输出。</p><a id="more"></a><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>题目要求前后交替输出。既我们可以先找出链表的中间节点。找中间节点可以用快慢指针来实现。那么链表就可以分成2部分。一部分前缀为从起始点到中间节点前一个位置组成的链表。另一部分后缀为中间节点到最后一个节点组成的链表。然后再对后面这部分的链表进行反序。然后用前面组成的链表，和这个反序链表进行交替取节点组成新的链表。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">ListNode* firstHead = <span class="literal">NULL</span>;</span><br><span class="line">ListNode* secondHead = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span> || head-&gt;next-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ListNode* slowPrePointer = <span class="literal">NULL</span>;</span><br><span class="line">ListNode* slowPointer = head;</span><br><span class="line">ListNode* fastPointer = head;</span><br><span class="line"><span class="keyword">while</span>(slowPointer != <span class="literal">NULL</span> &amp;&amp; fastPointer != <span class="literal">NULL</span> &amp;&amp; fastPointer-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">slowPrePointer = slowPointer;</span><br><span class="line">slowPointer = slowPointer-&gt;next;</span><br><span class="line">fastPointer = fastPointer-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">slowPrePointer-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">firstHead = head;</span><br><span class="line">secondHead = slowPointer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reverse odd list</span></span><br><span class="line">ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">ListNode* cur = secondHead;</span><br><span class="line">ListNode* next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>(cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">next = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">cur-&gt;next = pre;</span><br><span class="line">pre = cur;</span><br><span class="line">cur = next;</span><br><span class="line">next = cur != <span class="literal">NULL</span> ? cur-&gt;next : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">secondHead = pre;</span><br><span class="line"></span><br><span class="line">ListNode* firstCurrent = firstHead;</span><br><span class="line">ListNode* secondCurrent = secondHead;</span><br><span class="line">        ListNode* current = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(firstCurrent != <span class="literal">NULL</span> &amp;&amp; secondCurrent != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(current == <span class="literal">NULL</span>) &#123;</span><br><span class="line">current = firstCurrent;</span><br><span class="line">firstCurrent = firstCurrent-&gt;next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">current-&gt;next = firstCurrent;</span><br><span class="line">current = firstCurrent;</span><br><span class="line">firstCurrent = firstCurrent-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">current-&gt;next = secondCurrent;</span><br><span class="line">current = secondCurrent;</span><br><span class="line">secondCurrent = secondCurrent-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>139. Word Break</title>
      <link href="/2020/08/08/leetecode/139-Word-Break/"/>
      <url>/2020/08/08/leetecode/139-Word-Break/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个字符串s和一个词典，要你判断这个字符串是否由词典里面的单词拼接而成。其中词典里的单词可以重复使用多次。<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>利用动态规划，dp[i]表示0~i的子字符串是否可以由词典里面的词组成。<br>那么状态方程为dp[i] = dp[j - 1] &amp;&amp;  (子字符串s[j…i]是否在词典里)。<br>dp[i]初始为子字符串s[0…i]是否在词典里。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; wordSet(wordDict.begin(), wordDict.end());</span><br><span class="line"><span class="keyword">if</span>(s.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> wordSet.find(s) != wordSet.end();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; dp(s.size(), <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">dp[i] =  (wordSet.find(s.substr(<span class="number">0</span>, i + <span class="number">1</span>)) != wordSet.end());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!dp[i] &amp;&amp; i &gt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">dp[i] = (dp[j - <span class="number">1</span>] &amp;&amp; (wordSet.find(s.substr(j, i -j + <span class="number">1</span>)) != wordSet.end()));</span><br><span class="line"><span class="keyword">if</span>(dp[i]) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[s.length() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>429. N-ary Tree Level Order Traversal</title>
      <link href="/2020/08/08/leetecode/429-N-ary-Tree-Level-Order-Traversal/"/>
      <url>/2020/08/08/leetecode/429-N-ary-Tree-Level-Order-Traversal/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>这道题跟<a href="https://daxiaoluo.github.io/2020/08/08/leetecode/102-Binary-Tree-Level-Order-Traversal/" target="_blank" rel="noopener">102. Binary Tree Level Order Traversal</a>类似，不同的是<a href="https://daxiaoluo.github.io/2020/08/08/leetecode/102-Binary-Tree-Level-Order-Traversal/" target="_blank" rel="noopener">102. Binary Tree Level Order Traversal</a>是二叉树，这里节点可以有多个孩子节点，数量不限制。<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>方法同<a href="https://daxiaoluo.github.io/2020/08/08/leetecode/102-Binary-Tree-Level-Order-Traversal/" target="_blank" rel="noopener">102. Binary Tree Level Order Traversal</a>一样，利用用一个特殊的节点NULL在队列里面指示当前层结束。不同的是，扩展子节点的时候，不是左右2个节点，是多个子节点。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; levelOrder(Node* root) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; result;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">result.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"><span class="built_in">queue</span>&lt;Node*&gt; que;</span><br><span class="line">que.push(root);</span><br><span class="line">que.push(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">while</span>(!que.empty()) &#123;</span><br><span class="line">Node* cur = que.front();</span><br><span class="line">que.pop();</span><br><span class="line"><span class="keyword">if</span>(cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">result[result.size() - <span class="number">1</span>].push_back(cur-&gt;val);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;Node*&gt;::iterator iter = (cur-&gt;children).begin(); iter !=  (cur-&gt;children).end(); iter++) &#123;</span><br><span class="line"><span class="keyword">if</span>(*iter != <span class="literal">NULL</span>) &#123;</span><br><span class="line">que.push(*iter);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(!que.empty()) &#123;</span><br><span class="line">result.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">que.push(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>107. Binary Tree Level Order Traversal II</title>
      <link href="/2020/08/08/leetecode/107-Binary-Tree-Level-Order-Traversal-II/"/>
      <url>/2020/08/08/leetecode/107-Binary-Tree-Level-Order-Traversal-II/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>这道题跟<a href="https://daxiaoluo.github.io/2020/08/08/leetecode/102-Binary-Tree-Level-Order-Traversal/" target="_blank" rel="noopener">102. Binary Tree Level Order Traversal</a>类似，不同的是，需要得到逆向的层序结果。<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>可以用递归的方法，用当前层的子节点给下次递归扩展。然后在保存当前层的节点。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; result;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> == root) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;TreeNode*&gt; curLevelNodes;</span><br><span class="line">curLevelNodes.push_back(root);</span><br><span class="line">levelAssist(result, curLevelNodes);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelAssist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; result, <span class="built_in">vector</span>&lt;TreeNode*&gt;&amp; levelNodes)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;TreeNode*&gt; curLevelNodes;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;TreeNode*&gt;::iterator iter = levelNodes.begin(); iter != levelNodes.end(); iter++) &#123;</span><br><span class="line">values.push_back((*iter)-&gt;val);</span><br><span class="line"><span class="keyword">if</span>((*iter)-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">curLevelNodes.push_back((*iter)-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>((*iter)-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">curLevelNodes.push_back((*iter)-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!curLevelNodes.empty()) &#123;</span><br><span class="line">levelAssist(result, curLevelNodes);</span><br><span class="line">&#125;</span><br><span class="line">result.push_back(values);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>102. Binary Tree Level Order Traversal</title>
      <link href="/2020/08/08/leetecode/102-Binary-Tree-Level-Order-Traversal/"/>
      <url>/2020/08/08/leetecode/102-Binary-Tree-Level-Order-Traversal/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个二叉树，要求得到它的层序结果。层序结果如下图解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">   /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>得到的层序结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>题目的要求是按层来遍历二叉树，利用队列就能实现按层来遍历。初始将root节点加入到队列，每次从队列头部弹出节点输出，若其子节点不为空，则按顺序将左子节点和右子节点加入到队列，进行下一轮的扩展。直到队列为空。但是这里要求直到每一层的节点个数。如果这一层的节点输出完，需要另起一行或者另起</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; result;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> == root) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">result.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"><span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">que.push(root);</span><br><span class="line">que.push(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">while</span>(!que.empty()) &#123;</span><br><span class="line">TreeNode *cur = que.front();</span><br><span class="line">que.pop();</span><br><span class="line"><span class="keyword">if</span>(cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">result[result.size() - <span class="number">1</span>].push_back(cur-&gt;val);</span><br><span class="line"><span class="keyword">if</span>(cur-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">que.push(cur-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cur-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">que.push(cur-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(!que.empty()) &#123;</span><br><span class="line">que.push(<span class="literal">NULL</span>);</span><br><span class="line">result.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>130. Surrounded Regions</title>
      <link href="/2020/08/08/leetecode/130-Surrounded-Regions/"/>
      <url>/2020/08/08/leetecode/130-Surrounded-Regions/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个2维的矩阵，其中每个方格里面的字符为’X’或者为’O’。需要你找出所有被’X’包围的区域，并且将这部分区域填充为’X’。<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>题目要求找到被’X’包围的区域并且填充。我们可以先找到’X’不能包围的区域，做上标记，然后扫描整个矩阵，把未标记的区域填充为’X’,既为我们所要求的结果。要找到不被’X’包围的区域，它必然会延伸到矩阵的边缘。所以我们只需要扫描矩阵边缘，找到格子里面字符不为’X’的格子，进行DFS扩展，既可以标记出不被’X’包围的区域。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void solve(vector&lt;vector&lt;char&gt; &gt;&amp; board) &#123;</span><br><span class="line">if(board.size() == 0) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;bool&gt; &gt; visited(board.size(), vector&lt;bool&gt;(board[0].size(), false));</span><br><span class="line">for(int i = 0; i &lt; board.size(); i++) &#123;</span><br><span class="line">if(board[i][0] == &apos;O&apos; &amp;&amp; !visited[i][0]) &#123;</span><br><span class="line">dfs(board, visited, i, 0);</span><br><span class="line">&#125;</span><br><span class="line">if(board[i][board[i].size() - 1] == &apos;O&apos; &amp;&amp; !visited[i][board[i].size() - 1]) &#123;</span><br><span class="line">dfs(board, visited, i, board[i].size() - 1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int j = 0; j &lt; board[0].size(); j++) &#123;</span><br><span class="line">if(board[0][j] == &apos;O&apos; &amp;&amp; !visited[0][j]) &#123;</span><br><span class="line">dfs(board, visited, 0, j);</span><br><span class="line">&#125;</span><br><span class="line">if(board[board.size() - 1][j] == &apos;O&apos; &amp;&amp; !visited[board.size() - 1][j]) &#123;</span><br><span class="line">dfs(board, visited, board.size() - 1, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(int i = 0; i &lt; board.size(); i++) &#123;</span><br><span class="line">for(int j = 0; j &lt; board[i].size(); j++) &#123;</span><br><span class="line">if(!visited[i][j]) &#123;</span><br><span class="line">board[i][j] = &apos;X&apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">void dfs(vector&lt;vector&lt;char&gt; &gt;&amp; board,  vector&lt;vector&lt;bool&gt; &gt;&amp; visited, int i, int j) &#123;</span><br><span class="line">if(i &lt; 0 || j &lt; 0 || i &gt;= board.size() || j &gt;= board[i].size()) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if(board[i][j] == &apos;X&apos; || visited[i][j]) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">visited[i][j] = true;</span><br><span class="line">dfs(board, visited, i - 1, j);</span><br><span class="line">dfs(board, visited, i + 1, j);</span><br><span class="line">dfs(board, visited, i, j - 1);</span><br><span class="line">dfs(board, visited, i, j + 1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>223. Rectangle Area</title>
      <link href="/2020/04/02/leetecode/223-Rectangle-Area/"/>
      <url>/2020/04/02/leetecode/223-Rectangle-Area/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定分别给出两个矩阵的对角坐标，求两个矩阵占的面积。<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>题目不难，求解方法是求出两个矩阵共同的面积，把两个矩阵的面积和减去共同的面积，则为最终解。这里需要注意两个面积相加可能出现溢出的情况，所以可以用一个矩阵的面积减去共同占用的面积再加上另外一个矩阵的面积。求两个矩阵的共同面积，分三种情况，1)一个矩阵包含另一个矩阵,2)两个矩阵相交,3)两个矩阵不相交。求共同占用的面积，如果存在，它也是一个矩阵，只要求出它的对角的两个坐标。这个矩阵最左下角的横轴的坐标x1为两个矩阵最左下角的点对应的横轴的最大值，同理最右上角的横轴坐标x2为两个矩阵最右上角的点对应的横轴的最小值。有相交的矩阵时，x2的值大于x1的，不相交的时候，x2会比x1小，这不符合情况。所以为了应对不想交的情况，x2还要和x1进行比较，x2取最大值。同理可以求出y1,y2。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">computeArea</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> C, <span class="keyword">int</span> D, <span class="keyword">int</span> E, <span class="keyword">int</span> F, <span class="keyword">int</span> G, <span class="keyword">int</span> H)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> areaOne = (C - A) * (D - B);</span><br><span class="line"><span class="keyword">int</span> areaTwo = (G - E) * (H - F);</span><br><span class="line"><span class="comment">//求相交的面积</span></span><br><span class="line"><span class="keyword">int</span> x1 = max(A, E);</span><br><span class="line"><span class="keyword">int</span> x2 = max(x1, min(C, G));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> y1 = max(B, F);</span><br><span class="line"><span class="keyword">int</span> y2 = max(y1, min(D, H));</span><br><span class="line"><span class="keyword">return</span> areaOne + areaTwo - (x2 - x1) * (y2 - y1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>480. Sliding Window Median</title>
      <link href="/2020/04/01/leetecode/480-Sliding-Window-Median/"/>
      <url>/2020/04/01/leetecode/480-Sliding-Window-Median/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个数组，要求你按照k窗口滑动，每次滑动一格，要求求出窗口中的中位数。如果k为奇数，则输出中位数。如果为偶数，则把排序后中间的2个数的平均所得的值作为平均数。<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这题直接参照<a href="https://www.jianshu.com/p/affef3d19012" target="_blank" rel="noopener">Shiyi001</a>的题解。这里在进行一些解释。这题跟<a href="https://daxiaoluo.github.io/2020/02/03/leetecode/295-Find-Median-from-Data-Stream/" target="_blank" rel="noopener">295. Find Median from Data Stream</a>解法类似。用一个大根堆作为左子树，小根堆作为右子树，并且保证右子树的所有数都大于左子树中的所有数。而且保证左边的数的高度和右边的子树高度相等，或者比右子树高一层。这样，在两颗子树保存的总的节点数为奇数时，左子树的根节点就是中位数。若为偶数，左子树的根节点与右子树的根节点的平均既为中位数。但是由于要求的是一个滑动的窗口k，那么每次滑动一格时候，需要对左右两棵树进行操作，将窗口外最左边的数给删除，然后加入新的节点。由于堆的结构特性，很难直接定位做到直接删除。在Shiyi001的方法里面，对于要删除的点，如果均不在左右子树的根节点时。用一个hash map记录，表示为一个无效节点。待后面添加完新节点后，做完调整后，再统一做删除操作，看左右子树的根节点是否是个无效的节点。如果是则删除。<br><br>其中，用一个balance来表示左子树和右子树的相对高度差。假如左子树和右子树原本的高度差为h,这个h表示height(left tree) - height(right tree)。这个h要满足条件，只能为0或者1。所以再删除和增加节点后，h也必须保证不变。用h + balance表示增加节点和删除节点没有做调整的时候的高度差。所以当滑动一个窗口的时候，如果需要删除的节点m在左子树时，即m &lt;= left.top(); balance减1。如果在右子树，既 m &gt; left.top()，则balance加1。此时h + balance表示删除后的左子树和右子树的高度差。当增加一个数n时候，所有考虑是否可以加入左子树。只有在左子树不为空，且加入的n &lt;= left.top()才能加入，balance加1。否则加入到右子树，balance减1。balance的结果只可能为-2, 0, +2。后面做左右子树调整，只需要做一次就可以使得balance为0。保持原来的h高度差。如果balance &gt; 0。将左子树的根节点弹出压入右子树。也既左子树的高度减1，右子树的高度加1，所以调整后balance等于0。同理，当balance &lt; 0时，将右子树的根节点弹出压入左子树。balance为0时，不需要调整左右子树。调整完后再检查左右子树的根节点，看是否是无效的节点，无效的节点删除，再检查，直到是有效节点为止。然后根据k的情况，通过两颗数的根节点求中位数。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; medianSlidingWindow(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; medians;</span><br><span class="line"><span class="keyword">if</span>(nums.size() &lt; k) &#123;</span><br><span class="line"><span class="keyword">return</span> medians;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; invalid;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; leftMaxHeap;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;  &gt; rightMinHeap;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; i &lt; k; i++) &#123;</span><br><span class="line">leftMaxHeap.push(nums[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; k / <span class="number">2</span>; c++) &#123;</span><br><span class="line">rightMinHeap.push(leftMaxHeap.top());</span><br><span class="line">leftMaxHeap.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i &lt;= nums.size()) &#123;</span><br><span class="line"><span class="keyword">if</span>(k % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">medians.push_back((<span class="keyword">double</span>)leftMaxHeap.top());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">medians.push_back((leftMaxHeap.top() + rightMinHeap.top()) / <span class="number">2.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i &gt;= nums.size()) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = nums[i - k];</span><br><span class="line"><span class="keyword">int</span> n = nums[i++];</span><br><span class="line"><span class="keyword">int</span> balance = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(m &lt;= leftMaxHeap.top()) &#123;</span><br><span class="line">balance--;</span><br><span class="line"><span class="keyword">if</span>(m == leftMaxHeap.top()) &#123;</span><br><span class="line">leftMaxHeap.pop();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">invalid[m]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">balance++;</span><br><span class="line"><span class="keyword">if</span>(m == rightMinHeap.top()) &#123;</span><br><span class="line">rightMinHeap.pop();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">invalid[m]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!leftMaxHeap.empty() &amp;&amp; n &lt;= leftMaxHeap.top()) &#123;</span><br><span class="line">balance++;</span><br><span class="line">leftMaxHeap.push(n);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">balance--;</span><br><span class="line">rightMinHeap.push(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(balance &lt; <span class="number">0</span>) &#123;</span><br><span class="line">leftMaxHeap.push(rightMinHeap.top());</span><br><span class="line">rightMinHeap.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(balance &gt; <span class="number">0</span>) &#123;</span><br><span class="line">rightMinHeap.push(leftMaxHeap.top());</span><br><span class="line">leftMaxHeap.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!leftMaxHeap.empty() &amp;&amp; invalid[leftMaxHeap.top()] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">invalid[leftMaxHeap.top()]--;</span><br><span class="line">leftMaxHeap.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!rightMinHeap.empty() &amp;&amp; invalid[rightMinHeap.top()] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">invalid[rightMinHeap.top()]--;</span><br><span class="line">rightMinHeap.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> medians;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>460. LFU Cache</title>
      <link href="/2020/03/30/leetecode/460-LFU-Cache/"/>
      <url>/2020/03/30/leetecode/460-LFU-Cache/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>要你设计一个缓存。当存数据的时，缓存达到空间限制，淘汰掉最少使用的(key,value)数据。当淘汰的数据出现多个频率相同的(key,value)数据时。淘汰最早加入的数据。<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>用一个map来存储&lt;key, value&gt;对，每个value表示为一个CacheNode节点。另外一个map用来存储访问的频率对应的那些节点的key list。当一个节点被访问的时候，如果存在在cache中。对应的频率加1，将它在原先旧的频率列表里面删除，加入到新的频率列表头部。当加入一个新的节点的时候，如果key存在在cache里面，则改变对应的value值，按照上述读的方式改变频率对应的key list。如果不存在，则判断是否超出了设定的容量。如果超出了，则找到最小频率对应的key list，删除尾部保存的key对应的数据，然后再添加新的数据。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CacheNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> key;</span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">int</span> freq;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LFUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">       _minFreq = <span class="number">0</span>;</span><br><span class="line">   _capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, CacheNode&gt;::iterator iter = cache.find(key);</span><br><span class="line"><span class="keyword">if</span>(iter != cache.end()) &#123;</span><br><span class="line">touch(iter-&gt;second);</span><br><span class="line"><span class="keyword">return</span> iter-&gt;second.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(_capacity == <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, CacheNode&gt;::iterator iter = cache.find(key);</span><br><span class="line">   <span class="keyword">if</span>(iter != cache.end()) &#123;</span><br><span class="line">   iter-&gt;second.value = value;</span><br><span class="line">   touch(iter-&gt;second);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(cache.size() == _capacity) &#123;</span><br><span class="line">   <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; &gt;::iterator iter = freqIndex.find(_minFreq);</span><br><span class="line">   <span class="keyword">int</span> delKey = iter-&gt;second.back();</span><br><span class="line">   iter-&gt;second.pop_back();</span><br><span class="line">   cache.erase(delKey);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   _minFreq = <span class="number">1</span>;</span><br><span class="line">   freqIndex[<span class="number">1</span>].push_front(key);</span><br><span class="line"></span><br><span class="line">   CacheNode cacheNode = &#123;key, value, <span class="number">1</span>, freqIndex[<span class="number">1</span>].begin()&#125;;</span><br><span class="line">   cache[key] = cacheNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch</span><span class="params">(CacheNode &amp;node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> oldFreq = node.freq;</span><br><span class="line">freqIndex[node.freq].erase(node.it);</span><br><span class="line"><span class="keyword">if</span>(freqIndex[node.freq].empty()) &#123;</span><br><span class="line">freqIndex.erase(node.freq);</span><br><span class="line"><span class="keyword">if</span>(node.freq == _minFreq) &#123;</span><br><span class="line">_minFreq++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">node.freq++;</span><br><span class="line">freqIndex[node.freq].push_front(node.key);</span><br><span class="line">node.it = freqIndex[node.freq].begin();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _minFreq;</span><br><span class="line"><span class="keyword">int</span> _capacity;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, CacheNode&gt; cache;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; &gt; freqIndex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LFUCache* obj = new LFUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>895. Maximum Frequency Stack</title>
      <link href="/2020/03/10/leetecode/895-Maximum-Frequency-Stack/"/>
      <url>/2020/03/10/leetecode/895-Maximum-Frequency-Stack/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>要你设计一个栈结构。每次会push进一个整数x, 当做pop操作时，需要将当前栈中出现频率最多的数弹出。如果频率相等，则弹出最近压进栈的数。<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>按照<a href="https://www.bilibili.com/video/av31145075?from=search&amp;seid=17354864031750112919" target="_blank" rel="noopener">花花酱</a>方法。由于频数是连续的，所以用一个连续的数组来存储多个栈，每个数组元素i表示存频数为i + 1的栈。用一个hashtable来存储压入栈的各个数出现的频率，以此来判断压入一个数时候，应该选择哪个数组元素对应的栈进行压栈操作。当需要pop操作时，数组最大的位置保存的栈就是最大频率的数。由于数组每个元素对应一个栈结构，本身就带了栈的性质。所以相同频数的情况下，当前这个位置会弹出最后压进栈的数。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-实现代码"><a href="#C-实现代码" class="headerlink" title="C++实现代码"></a>C++实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FreqStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FreqStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator iter = index.find(x);</span><br><span class="line"><span class="keyword">int</span> freq = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(iter == index.end()) &#123;</span><br><span class="line">index[x] = <span class="number">1</span>;</span><br><span class="line">freq = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">freq = ++iter-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(stacks.size() &lt; freq) &#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">s.push(x);</span><br><span class="line">stacks.push_back(s);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">stacks[freq - <span class="number">1</span>].push(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = stacks[stacks.size() - <span class="number">1</span>].top();</span><br><span class="line">stacks[stacks.size() - <span class="number">1</span>].pop();</span><br><span class="line"><span class="keyword">if</span>(stacks[stacks.size() - <span class="number">1</span>].empty()) &#123;</span><br><span class="line">stacks.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator iter = index.find(x);</span><br><span class="line">--iter-&gt;second;</span><br><span class="line"><span class="keyword">if</span>(iter-&gt;second == <span class="number">0</span>) &#123;</span><br><span class="line">index.erase(iter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; &gt; stacks;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; index;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your FreqStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * FreqStack* obj = new FreqStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>301. Remove Invalid Parentheses</title>
      <link href="/2020/03/09/leetecode/301-Remove-Invalid-Parentheses/"/>
      <url>/2020/03/09/leetecode/301-Remove-Invalid-Parentheses/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个字符串，要求你删除最少的括号，使这个表达式是个合法的表达式。<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>完全是参考<a href="https://www.bilibili.com/video/av31665179?from=search&amp;seid=11008217076334050979" target="_blank" rel="noopener">花花酱</a>的思路。用DFS来求解。<br>要确定几个步骤：<br><br>1.从左至右扫描字符串，确定要删除的左括号和右括号分别有多少个。<br>要保证括号合法，假设字符串长度为n, 当i &lt; n时，要保证右括号的数量小于等于左括号的数量。当i == n时，左括号和右括号的数量相等。<br><br>2.当确定好了要删除的左括号和右括号的数量时，用dfs搜索来确定结果。用dfs顺序扫描字符串，要保证先删除右括号，待右括号为0时，再考虑删除左括号的情况。这是因为要保证扫描到的前缀是合法的。<br><br>3.在递归删除字符串里面左括号或者右括号的时候，分别对应出现有连续的左括号或右括号时，优先删除第一个，避免出现重复情况出现，起到搜索剪枝的作用。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-实现代码"><a href="#C-实现代码" class="headerlink" title="C++实现代码"></a>C++实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; removeInvalidParentheses(<span class="built_in">string</span> s) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line"><span class="keyword">int</span> delLeft = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> delRight = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(s[i] == <span class="string">'('</span>) &#123;</span><br><span class="line">left++;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">right++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(right &gt; left) &#123;</span><br><span class="line">delRight++;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">delLeft = left - right;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; acc;</span><br><span class="line">dfs(s, <span class="number">0</span>, delLeft, delRight, acc, result);</span><br><span class="line"><span class="keyword">if</span>(result.size() == <span class="number">0</span>) &#123;</span><br><span class="line">result.push_back(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> index, <span class="keyword">int</span> delLeft, <span class="keyword">int</span> delRight, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &amp;acc, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;result)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除了需要的左右括号的数量，检查是否合法</span></span><br><span class="line"><span class="keyword">if</span>(delLeft == <span class="number">0</span> &amp;&amp; delRight == <span class="number">0</span> &amp;&amp; index &lt;= s.length()) &#123;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">ss</span><span class="params">(acc.begin(), acc.end())</span></span>;</span><br><span class="line"><span class="keyword">if</span>(index &lt; s.length()) &#123;</span><br><span class="line">ss += s.substr(index, s.length() - index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(check(ss, <span class="number">0</span>)) &#123;</span><br><span class="line">result.push_back(ss);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(index &gt;= s.length()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(s[index] == <span class="string">'('</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(delRight == <span class="number">0</span> &amp;&amp; delLeft &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//delete the first left parenthes</span></span><br><span class="line">dfs(s, index + <span class="number">1</span>, delLeft - <span class="number">1</span>, delRight, acc, result);</span><br><span class="line"></span><br><span class="line"><span class="comment">//retain the consecutive left parentheses</span></span><br><span class="line"><span class="keyword">int</span> nextIndex = index;</span><br><span class="line"><span class="keyword">while</span>(nextIndex &lt; s.length() &amp;&amp; s[nextIndex] == <span class="string">'('</span>) &#123;</span><br><span class="line">acc.push_back(s[nextIndex]);</span><br><span class="line">nextIndex++;</span><br><span class="line">&#125;</span><br><span class="line">dfs(s, nextIndex, delLeft, delRight, acc, result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; nextIndex; i++) &#123;</span><br><span class="line">acc.pop_back();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//需要先删除右括号保证前缀合法</span></span><br><span class="line">acc.push_back(s[index]);</span><br><span class="line">dfs(s, index + <span class="number">1</span>, delLeft, delRight, acc, result);</span><br><span class="line">acc.pop_back();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(s[index] == <span class="string">')'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(delRight &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//delete the first right parenthes</span></span><br><span class="line">dfs(s, index + <span class="number">1</span>, delLeft, delRight - <span class="number">1</span>, acc, result);</span><br><span class="line"></span><br><span class="line"><span class="comment">//retain the consecutive right parentheses</span></span><br><span class="line"><span class="keyword">int</span> nextIndex = index;</span><br><span class="line"><span class="keyword">while</span>(nextIndex &lt; s.length() &amp;&amp; s[nextIndex] == <span class="string">')'</span>) &#123;</span><br><span class="line">acc.push_back(s[nextIndex]);</span><br><span class="line">nextIndex++;</span><br><span class="line">&#125;</span><br><span class="line">dfs(s, nextIndex, delLeft, delRight, acc, result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; nextIndex; i++) &#123;</span><br><span class="line">acc.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">acc.push_back(s[index]);</span><br><span class="line">dfs(s, index + <span class="number">1</span>, delLeft, delRight, acc, result);</span><br><span class="line">acc.pop_back();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">acc.push_back(s[index]);</span><br><span class="line">dfs(s, index + <span class="number">1</span>, delLeft, delRight, acc, result);</span><br><span class="line">acc.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(s[i] == <span class="string">'('</span>) &#123;</span><br><span class="line">left++;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">right++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(right &gt; left) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> right == left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>928. Minimize Malware Spread II</title>
      <link href="/2020/03/02/leetecode/928-Minimize-Malware-Spread-II/"/>
      <url>/2020/03/02/leetecode/928-Minimize-Malware-Spread-II/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>跟<a href="https://daxiaoluo.github.io/2020/02/06/leetecode/924-Minimize-Malware-Spread/" target="_blank" rel="noopener">924.Minimize Malware Spread</a>类型，不同的是，如果有初始感染节点A和B,如果A和B能够互相到达，若删除A后，B就不会再感染A，也不能通过A感染其他节点。</p><a id="more"></a><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>方法一: <br><br>用dfs的方法。从各个初始的感染节点出发，在遍历其中一个感染节点的时候，其他初始感染节点从图中删除，用dfs求出哪些节点会被当前遍历的初始感染节点感染。最后统计被初始感染节点感染一次的节点数，被初始感染节点感染最多的节点，就是所求。<br></p><p>方法二: <br><br>跟<a href="https://daxiaoluo.github.io/2020/02/06/leetecode/924-Minimize-Malware-Spread/" target="_blank" rel="noopener">924.Minimize Malware Spread</a>类似，采用并查集的方法。首先在图中删除所有初始感染节点，然后求这个图中的所有连通子图。然后遍历初始感染节点，看它能够感染哪些连通子图。然后在这些连通子图中过滤出只被一个初始感染节点感染的连通子图，求最大的连通子图，其对应的初始感染节点既为所求。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-实现代码"><a href="#C-实现代码" class="headerlink" title="C++实现代码"></a>C++实现代码</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minMalwareSpread</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; initial)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; nodes(graph.size());</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited(graph.size(), <span class="number">-2</span>);</span><br><span class="line">sort(initial.begin(), initial.end());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initial.size(); i++) &#123;</span><br><span class="line"> visited[initial[i]] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initial.size(); i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph[initial[i]].size(); j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(graph[initial[i]][j] == <span class="number">1</span>) &#123;</span><br><span class="line">dfs(graph, j, nodes, visited, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; counts(initial.size(), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(nodes[i].size() == <span class="number">1</span>) &#123;</span><br><span class="line">counts[nodes[i][<span class="number">0</span>]]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initial.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(ans &lt; counts[i]) &#123;</span><br><span class="line">ans = counts[i];</span><br><span class="line">result = initial[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ans == <span class="number">0</span> ? initial[<span class="number">0</span>] : result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="keyword">int</span> current, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;nodes, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;visited, <span class="keyword">int</span> infector)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(visited[current] == infector || visited[current] == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">visited[current] = infector;</span><br><span class="line">nodes[current].push_back(infector);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[current].size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(graph[current][i] == <span class="number">1</span>) &#123;</span><br><span class="line">dfs(graph, i, nodes, visited, infector);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">DSU(<span class="keyword">int</span> size):parent(size, <span class="number">-1</span>), sz(size, <span class="number">1</span>) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(parent[node] == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">parent[node] = findRoot(parent[node]);</span><br><span class="line"><span class="keyword">return</span> parent[node];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionNodes</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> xRoot = findRoot(x);</span><br><span class="line"><span class="keyword">int</span> yRoot = findRoot(y);</span><br><span class="line"><span class="keyword">if</span>(xRoot == yRoot) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">parent[xRoot] = yRoot;</span><br><span class="line">sz[yRoot] += sz[xRoot];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sz[findRoot(node)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sz;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minMalwareSpread</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; graph, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; initial)</span> </span>&#123;</span><br><span class="line"><span class="function">DSU <span class="title">dsu</span><span class="params">(graph.size())</span></span>;</span><br><span class="line">sort(initial.begin(), initial.end());</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; helper(graph.size(), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = initial.begin(); iter != initial.end(); iter++) &#123;</span><br><span class="line">helper[*iter] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.size(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; graph[i].size(); j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(graph[i][j] == <span class="number">1</span> &amp;&amp; helper[i] == <span class="number">0</span> &amp;&amp; helper[j] == <span class="number">0</span>) &#123;</span><br><span class="line">dsu.unionNodes(i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; colors(graph.size(), <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; infectedNodes(graph.size());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initial.size(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph[initial[i]].size(); j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(graph[initial[i]][j] == <span class="number">1</span> &amp;&amp; helper[j] != <span class="number">1</span>) &#123; <span class="comment">//连接的点是初始感染节点忽略</span></span><br><span class="line"><span class="keyword">int</span> r = dsu.findRoot(j);</span><br><span class="line"><span class="keyword">if</span>(colors[r] != initial[i]) &#123;</span><br><span class="line">infectedNodes[r].push_back(initial[i]);</span><br><span class="line">colors[r] = initial[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(infectedNodes[i].size() == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> sz = dsu.getSize(i);</span><br><span class="line"><span class="keyword">if</span>(ans &lt; sz) &#123;</span><br><span class="line">ans = sz;</span><br><span class="line">result = infectedNodes[i][<span class="number">0</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(ans == sz) &#123;</span><br><span class="line"><span class="keyword">if</span>(result &gt; infectedNodes[i][<span class="number">0</span>]) &#123;</span><br><span class="line">result = infectedNodes[i][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result == <span class="number">-1</span> ? initial[<span class="number">0</span>] : result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>924.Minimize Malware Spread</title>
      <link href="/2020/02/06/leetecode/924-Minimize-Malware-Spread/"/>
      <url>/2020/02/06/leetecode/924-Minimize-Malware-Spread/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个无向图，和一些初始节点。这些初始节点表示被感染的节点，它能够直接或者间接地感染图中的节点，只要通过它能到达的节点都会被感染。要求你只能在初始节点里面删除一个，使得其中感染节点的数最少。如果感染节点数一样，则输出序列最小的初始节点。注意，如果初始节点有A和B,通过A能够到达B，即使删除了A节点，由于A可以到达B，反之B也能到达A，感染A，通过A感染与A邻接的节点继续扩散下去，所以删除A达不到减少感染节点的目的。<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>其实就是找无向图的连通子图，如果连通子图里面有两个初始感染节点，删除任何一个初始感染节点，这个连通子图还是会被感染。所以需要找出只有一个初始感染节点的连通子图，在里面求出最大的连通子图。这个最大连通子图包含的初始感染节点就是所要删除的节点。<br><br>方法一:<br><br>通过dfs来找出无向图的连通子图。然后找出哪些连通子图里只包含一个初始感染节点。然后求出最大的连通子图。<br><br>方法二:<br><br>方法二见<a href="https://leetcode.com/problems/minimize-malware-spread/solution/" target="_blank" rel="noopener">官方题解</a>,采用并查集的方法，将graph看成是个无向连通图，求最大连通图。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-实现代码"><a href="#C-实现代码" class="headerlink" title="C++实现代码"></a>C++实现代码</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minMalwareSpread</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; initial)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; colors(graph.size(), <span class="number">-1</span>);<span class="comment">//标记连通子图，相同颜色的节点在一个连通子图里</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(colors[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">dfs(graph, i, colors, c); <span class="comment">//找出连通子图</span></span><br><span class="line">c++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; colorsCount(c, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; colors.size(); i++) &#123;</span><br><span class="line">colorsCount[colors[i]]++; <span class="comment">//求出每个连通子图的节点个数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(initial.begin(), initial.end());</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; infectColorCount(c, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = initial.begin(); iter != initial.end(); iter++) &#123;</span><br><span class="line">infectColorCount[colors[*iter]]++; <span class="comment">//初始感染节点在哪些连通子图里</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = initial.begin(); iter != initial.end(); iter++) &#123;</span><br><span class="line"><span class="keyword">if</span>(infectColorCount[colors[*iter]] == <span class="number">1</span>) &#123; <span class="comment">//只在包含一个初始感染节点的连通子图里面求最大的连通子图</span></span><br><span class="line"><span class="keyword">if</span>(colorsCount[colors[*iter]] &gt; ans) &#123;</span><br><span class="line">ans = colorsCount[colors[*iter]];</span><br><span class="line">result = *iter;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result == <span class="number">-1</span> ? initial[<span class="number">0</span>] : result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="keyword">int</span> current, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;colors, <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">colors[current] = color;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[current].size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(graph[current][i] == <span class="number">1</span> &amp;&amp; colors[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">dfs(graph, i, colors, color);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">DSU(<span class="keyword">int</span> size):parent(size, <span class="number">-1</span>), sz(size, <span class="number">1</span>) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(parent[node] == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">parent[node] = find_root(parent[node]);</span><br><span class="line"><span class="keyword">return</span> parent[node];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union_nodes</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x_root = find_root(x);</span><br><span class="line"><span class="keyword">int</span> y_root = find_root(y);</span><br><span class="line"><span class="keyword">if</span>(x_root == y_root) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">parent[x_root] = y_root;</span><br><span class="line">sz[y_root] += sz[x_root];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_size</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sz[find_root(node)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sz;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minMalwareSpread</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; initial)</span> </span>&#123;</span><br><span class="line"><span class="function">DSU <span class="title">dsu</span><span class="params">(graph.size())</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.size(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; graph[i].size(); j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(graph[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">dsu.union_nodes(i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(graph.size(), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initial.size(); i++) &#123;</span><br><span class="line">count[dsu.find_root(initial[i])]++;</span><br><span class="line">&#125;</span><br><span class="line">sort(initial.begin(), initial.end());</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">-1</span>, ans_size = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initial.size(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> root = dsu.find_root(initial[i]);</span><br><span class="line"><span class="keyword">if</span>(count[root] == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> rootSize = dsu.get_size(initial[i]);</span><br><span class="line"><span class="keyword">if</span>(rootSize &gt; ans_size) &#123;</span><br><span class="line">ans = initial[i];</span><br><span class="line">ans_size = rootSize;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ans == <span class="number">-1</span> ? initial[<span class="number">0</span>] : ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>828. Unique Letter String</title>
      <link href="/2020/02/06/leetecode/828-Unique-Letter-String/"/>
      <url>/2020/02/06/leetecode/828-Unique-Letter-String/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个字符串S, 要你求S不同区间的S[i:j]子串里面，没有重复的字母。例如S为”LETTER”,不重复的字母有”L”和”R”。它的子串”ETT”,不重复的字母有”E”,要你把每个区间子串的不重复字母的出现的总和计算出来。其中S里面只出现大写字母。例如S为”ABC”,那么它的不同区间子串有”A”,”B”,”C”,”AB”,”BC” 和 “ABC”。它们对应的不重复字母总和为1 + 1 + 1 + 2 + 2 + 3 = 10。<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>按照给出的<a href="https://leetcode.com/problems/unique-letter-string/solution/" target="_blank" rel="noopener">题解</a>。<br><br>方法一：<br><br>我们要求每个区间子串的不重复字母的个数，然后在求它们的个数总和。可以这么看，S[i:]会产生很多子串，每个子串会对应有不重复的字母，每个子串对应的不重复字母的个数，我们把它们求和，用F(i)表示。而用F(i)[‘A’]表示上述情况子串不重复字母有’A’的情况有多少种。<br>那么F(i) = F(i)[‘A’] + F(i)[‘B’] + … + F(i)[‘Z’]。最终要求的结果则为F(0) + F(1) + ..+ F(S.length() - 1)。<br><br>假如’A’在S中的位置为[10, 13, 18]。那么 F(0)[‘A’]则为13 - 10 = 3。同理可以求出F(0)[‘其他字母’]，既可以求出F(0)。如果要求F(1)，它与F(0)基本相同，唯一不同的就是要对S[0]这个字母做特殊处理。假如S[0]这个字母为’B’,而’B’在S中的位置为[0, 3, 10]。那么F(0)[‘B’] = 3 - 0 = 3。由于’B’在0位置出现过，所以在求F(1)的时候F(1)[‘B’] = 10 - 3 = 7。所以F(1) = F(0) - F(0)[‘B’] + F(1)[‘B’]。同理通过F(i)可以求出F(i + 1)。把F(i)都求出，最后取总和就是最终结果。<br><br>方法二：<br><br>见<a href="https://leetcode.com/problems/unique-letter-string/discuss/128952/One-pass-O(N" target="_blank" rel="noopener">lee215</a>-Straight-Forward)的题解，讲得挺详细。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-实现代码"><a href="#C-实现代码" class="headerlink" title="C++实现代码"></a>C++实现代码</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniqueLetterString</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; indices;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++) &#123;</span><br><span class="line">indices[S[i]].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; peek(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">long</span> cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = indices.begin(); it != indices.end(); ++it) &#123;</span><br><span class="line">indices[it-&gt;first].push_back(S.length());</span><br><span class="line">            indices[it-&gt;first].push_back(S.length());</span><br><span class="line"><span class="keyword">int</span> index = it-&gt;first - <span class="string">'A'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; indexes = it-&gt;second;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get F(0)</span></span><br><span class="line">cur += indexes[peek[index] + <span class="number">1</span>] - indexes[peek[index]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++) &#123;</span><br><span class="line"><span class="comment">//cur is F(i)</span></span><br><span class="line">ans += cur;</span><br><span class="line"><span class="keyword">int</span> index = S[i] - <span class="string">'A'</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; indexes = indices.at(S[i]);</span><br><span class="line"><span class="keyword">int</span> old = indexes[peek[index] + <span class="number">1</span>] - indexes[peek[index]];</span><br><span class="line">peek[index]++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cur is F(i + 1)</span></span><br><span class="line">cur -= old;</span><br><span class="line">cur += indexes[peek[index] + <span class="number">1</span>] - indexes[peek[index]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>)(ans % <span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniqueLetterString(string S) &#123;</span><br><span class="line">unordered_map&lt;char, vector&lt;int&gt; &gt; indices;</span><br><span class="line">for(int i = 0; i &lt; S.length(); i++) &#123;</span><br><span class="line">indices[S[i]].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long ans = 0;</span><br><span class="line">for (auto it = indices.begin(); it != indices.end(); ++it) &#123;</span><br><span class="line">const vector&lt;int&gt;&amp; indexes = it-&gt;second;</span><br><span class="line">for(int i = 0; i &lt; indexes.size(); i++) &#123;</span><br><span class="line">long left = i &gt; 0 ? indexes[i] - indexes[i - 1] : indexes[i] + 1;</span><br><span class="line">long right = i &lt; indexes.size() - 1 ? indexes[i + 1] - indexes[i] : S.length() - indexes[i];</span><br><span class="line">ans += left * right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return (int)(ans % 1000000007);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>295. Find Median from Data Stream</title>
      <link href="/2020/02/03/leetecode/295-Find-Median-from-Data-Stream/"/>
      <url>/2020/02/03/leetecode/295-Find-Median-from-Data-Stream/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>有一串数字流，你需要提供一个类，这个类有添加数字的方法addNum，用来添加数字流的数字。另一个查找中位数的方法findMedian，用于查找当前数字流的中位数。如果当前数据流一共有奇数个数字，则输出排序后的中间数。如果为偶数个，则输出排序后中间两个数的平均值。<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>参考<a href="https://zxi.mytechroad.com/blog/leetcode/leetcode-295-find-median-from-data-stream/" target="_blank" rel="noopener">花花酱</a>的题解。每次添加一个数字，类似维护一个平衡二叉树。用一个最大堆和一个最小堆来存储数据流。最大堆看成是一个左子树，最小堆看成是一个右子树。要保证左子树保存的所有数要小于右子树保存的所有数字。并且左子树的大小要么等于右子树，或者比它多存一个数。那么当当前数字流的数字个数为奇数时，中位数就是左子树最大堆的根节点。若为偶数，中位数就是左子树最大堆的根节点和右子树最小堆的根节点的平均值。<br><br>分以下几种情况考虑添加数字:<br><br>1.当左子树最大堆为空时，是初始状态，将数字加入到最大堆。<br><br>2.当左子树最大堆保存的个数比右子树最小堆保存的个数多一个的时候，有以下两种情况:<br><br>2.1)当前加入的数字比左子树最大堆的根节点大时，将其直接加入右子树最小堆。<br><br>2.2)反之，则将左子树的根结点弹出加入到右子树最小堆，然后将当前数加入到左子树最大堆里面。<br>3.当左子树最大堆保存的个数等于右子树最小堆保存的个数，有以下两种情况:<br><br>3.1)当前加入的数字比右子树最小堆还要小，则将其直接加入左子树最大堆里面。<br><br>3.2)反之，则将右子树最小堆的根节点弹出加入到左子树最大堆里面，然后将当前数加入到右子树最小堆里面。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heap</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="built_in">array</span>.push_back(num);</span><br><span class="line"><span class="keyword">int</span> idx = <span class="built_in">array</span>.size() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> parent = (idx + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(parent &gt;= <span class="number">0</span> &amp;&amp; compare(<span class="built_in">array</span>[parent], num)) &#123;</span><br><span class="line"><span class="built_in">array</span>[idx] = <span class="built_in">array</span>[parent];</span><br><span class="line">idx = parent;</span><br><span class="line">parent = (idx + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">array</span>[idx] = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">array</span>[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> value = <span class="built_in">array</span>[<span class="built_in">array</span>.size() - <span class="number">1</span>];</span><br><span class="line"><span class="built_in">array</span>.pop_back();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = (idx + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> left = right - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> child = right;</span><br><span class="line"><span class="keyword">if</span>(right &gt;= <span class="built_in">array</span>.size() || !compare(<span class="built_in">array</span>[left], <span class="built_in">array</span>[right])) &#123;</span><br><span class="line">child = left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(child &lt; <span class="built_in">array</span>.size() &amp;&amp; compare(value, <span class="built_in">array</span>[child])) &#123;</span><br><span class="line"><span class="built_in">array</span>[idx] = <span class="built_in">array</span>[child];</span><br><span class="line">idx = child;</span><br><span class="line"></span><br><span class="line">right = (idx + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">left = right - <span class="number">1</span>;</span><br><span class="line">child = right;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(right &gt;= <span class="built_in">array</span>.size() || !compare(<span class="built_in">array</span>[left], <span class="built_in">array</span>[right])) &#123;</span><br><span class="line">child = left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">array</span>[idx] = value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">array</span>.empty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">array</span>.size();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span>:</span> <span class="keyword">public</span> Heap &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinHeap</span>:</span> <span class="keyword">public</span> Heap &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MedianFinder() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(maxHeap.empty()) &#123;</span><br><span class="line">maxHeap.push(num);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(maxHeap.size() == minHeap.size() + <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(num &gt; maxHeap.top()) &#123;</span><br><span class="line">minHeap.push(num);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">minHeap.push(maxHeap.pop());</span><br><span class="line">maxHeap.push(num);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(num &lt; minHeap.top()) &#123;</span><br><span class="line">maxHeap.push(num);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">maxHeap.push(minHeap.pop());</span><br><span class="line">minHeap.push(num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>((maxHeap.size() + minHeap.size()) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (maxHeap.top() + minHeap.top()) / <span class="number">2.0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">double</span>)(maxHeap.top());</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">MaxHeap maxHeap;</span><br><span class="line">MinHeap minHeap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>282.Expression Add Operators</title>
      <link href="/2020/02/01/leetecode/282-Expression-Add-Operators/"/>
      <url>/2020/02/01/leetecode/282-Expression-Add-Operators/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个字符串和一个target数字。要你对这个字符串中间插入一些’*‘,’-‘, ‘+’运算符，使其形成的算术表达式结果等于target。要求把所有满足条件的表达式求出来。<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>参考<a href="https://www.bilibili.com/video/av31473376?from=search&amp;seid=12588175238360449928" target="_blank" rel="noopener">花花酱</a>。用dfs深度优先求这道题的结果。需要注意以下几种情况：<br><br>1.中间结果对于int溢出的情况，这种情况需要排除。<br><br>2.中间的数字不能有0前缀，例如数字105,不能有1 * 05这种情况，05有0前缀，需要排除。<br><br>3.要注意运算符的优先级，’*‘运算符的优先级要高于其他两种运算符的优先级。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-实现代码"><a href="#C-实现代码" class="headerlink" title="C++实现代码"></a>C++实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; addOperators(<span class="built_in">string</span> num, <span class="keyword">int</span> target) &#123;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; expr;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num.length(); i++) &#123;</span><br><span class="line">   <span class="built_in">string</span> sub = num.substr(<span class="number">0</span>, i);</span><br><span class="line">   <span class="keyword">if</span>(i &gt; <span class="number">1</span> &amp;&amp; sub[<span class="number">0</span>] == <span class="string">'0'</span>) &#123;</span><br><span class="line">   <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">long</span> n = atol(sub.c_str());</span><br><span class="line">   <span class="keyword">if</span>(n &gt; INT_MAX) &#123;</span><br><span class="line">   <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   expr.push_back(sub);</span><br><span class="line">   dfs(num, i, (<span class="keyword">int</span>)n, (<span class="keyword">int</span>)n, target, result, expr);</span><br><span class="line">   expr.pop_back();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp;num, <span class="keyword">int</span> pos, <span class="keyword">int</span> previous, <span class="keyword">int</span> curResult, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;result, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;expr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pos &gt;= num.length()) &#123;</span><br><span class="line"><span class="keyword">if</span>(curResult == target) &#123;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator iter = expr.begin(); iter != expr.end(); iter++) &#123;</span><br><span class="line">s += *iter;</span><br><span class="line">&#125;</span><br><span class="line">result.push_back(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num.length() - pos; i++) &#123;</span><br><span class="line"><span class="built_in">string</span> sub = num.substr(pos, i);</span><br><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">1</span> &amp;&amp; sub[<span class="number">0</span>] == <span class="string">'0'</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n = atoi(sub.c_str());</span><br><span class="line"></span><br><span class="line">expr.push_back(<span class="string">"+"</span>);</span><br><span class="line">expr.push_back(sub);</span><br><span class="line">dfs(num, pos + i, n, curResult + n, target, result, expr);</span><br><span class="line">expr.pop_back();</span><br><span class="line">expr.pop_back();</span><br><span class="line"></span><br><span class="line">expr.push_back(<span class="string">"-"</span>);</span><br><span class="line">expr.push_back(sub);</span><br><span class="line">dfs(num, pos + i, -n, curResult - n, target, result, expr);</span><br><span class="line">expr.pop_back();</span><br><span class="line">expr.pop_back();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> temp = ((<span class="keyword">long</span>) previous) * n;</span><br><span class="line"><span class="keyword">if</span>(temp &gt; INT_MAX) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expr.push_back(<span class="string">"*"</span>);</span><br><span class="line">expr.push_back(sub);</span><br><span class="line">dfs(num, pos + i, (<span class="keyword">int</span>) temp, curResult - previous + ((<span class="keyword">int</span>) temp), target, result, expr);</span><br><span class="line">expr.pop_back();</span><br><span class="line">expr.pop_back();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>239. Sliding Window Maximum</title>
      <link href="/2020/01/29/leetecode/239-Sliding-Window-Maximum/"/>
      <url>/2020/01/29/leetecode/239-Sliding-Window-Maximum/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一组数字，和一个窗口k, 每次向右滑动一个数字，求每次滑动时候窗口k里面数字的最大值。<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>用一个单调递减的双向队列。扫描这组数，每次都对队列尾部添加数字，如果当前扫描的数字比队尾的数字大，由于当前扫描的数字位置在队列尾部的数字之后，所以说明队尾的数字不会在后面的滑动窗口里面，需要从队列中弹出，待队列为空，或者队列的尾部不再存在比当前数字小的数时候，将扫描的数字从尾部压入队列。另外每次滑动一次窗口的时候，需要判断队列的头部的坐标位置是否在窗口里面，如果不在，需要在队头部弹出。这样每次滑动到一个窗口，队列头部就是需求求的最大数字。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-实现代码"><a href="#C-实现代码" class="headerlink" title="C++实现代码"></a>C++实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxSlidingWindow(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; valueQue;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; indexQue;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!valueQue.empty() &amp;&amp; indexQue.front() &lt;= i - k) &#123;</span><br><span class="line">valueQue.pop_front();</span><br><span class="line">indexQue.pop_front();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!valueQue.empty() &amp;&amp; nums[i] &gt;= valueQue.back()) &#123;</span><br><span class="line">valueQue.pop_back();</span><br><span class="line">indexQue.pop_back();</span><br><span class="line">&#125;</span><br><span class="line">valueQue.push_back(nums[i]);</span><br><span class="line">indexQue.push_back(i);</span><br><span class="line"><span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">result.push_back(valueQue.front());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>126. Word Ladder II</title>
      <link href="/2020/01/29/leetecode/126-Word-Ladder-II/"/>
      <url>/2020/01/29/leetecode/126-Word-Ladder-II/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>这题是<a href="https://daxiaoluo.github.io/2020/01/17/leetecode/127-Word-Ladder/" target="_blank" rel="noopener">Word Ladder</a>的扩展，不同的是需要把所有的最短路径求出来。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>跟<a href="https://daxiaoluo.github.io/2020/01/17/leetecode/127-Word-Ladder/" target="_blank" rel="noopener">Word Ladder</a>这一题思路是一致的，用广度优先遍历，每次遍历时用一个map数据结构保存每一层的parent，既是通过那个字母变换过来的，之后通过dfs，从这个map中取得最短路径。另一种方法对齐优化，是采用双向bfs，每次用当前队列里面大小最小的节点进行扩展，也既扩展的子节点最小。在保存parent的时候，需要区分当前节点是从左边的节点扩展而来的，还是从右边扩展而来的。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-实现代码"><a href="#C-实现代码" class="headerlink" title="C++实现代码"></a>C++实现代码</h2><h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; findLadders(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList) &#123;</span><br><span class="line">       <span class="keyword">int</span> length = beginWord.length();</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; result;</span><br><span class="line">   <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; wordSet(wordList.begin(), wordList.end());</span><br><span class="line">   <span class="keyword">if</span>(wordSet.count(endWord) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">   wordSet.erase(beginWord);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; parents;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; extendSet;</span><br><span class="line">   extendSet.insert(beginWord);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">while</span>(!extendSet.empty() &amp;&amp; !found) &#123;</span><br><span class="line">   <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line">   <span class="keyword">for</span>(<span class="built_in">string</span> s : extendSet) &#123;</span><br><span class="line">   <span class="built_in">string</span> origin = s;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">   <span class="keyword">char</span> old = s[i];</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="string">'a'</span>; k &lt;= <span class="string">'z'</span>; k++) &#123;</span><br><span class="line">   <span class="keyword">if</span>(k == old) &#123;</span><br><span class="line">   <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   s[i] = k;</span><br><span class="line">   <span class="keyword">if</span>(wordSet.count(s) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   q.insert(s);</span><br><span class="line">   parents[s].push_back(origin);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(endWord == s) &#123;</span><br><span class="line">   found = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   s[i] = old;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   swap(extendSet, q);</span><br><span class="line">   <span class="keyword">for</span>(<span class="built_in">string</span> s : extendSet) &#123;</span><br><span class="line">   wordSet.erase(s);</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(!found) &#123;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; acc;</span><br><span class="line">   acc.push_back(endWord);</span><br><span class="line">   dfs(result, endWord, parents, acc);</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; &amp;result, <span class="built_in">string</span> &amp;currentWord, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; &amp;parents, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;acc)</span> </span>&#123;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt;::const_iterator got = parents.find(currentWord);</span><br><span class="line"><span class="keyword">if</span>(got == parents.end()) &#123;</span><br><span class="line">result.push_back(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(acc.rbegin(), acc.rend()));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">string</span> s : got-&gt;second) &#123;</span><br><span class="line">acc.push_back(s);</span><br><span class="line">dfs(result, s, parents, acc);</span><br><span class="line">acc.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; findLadders(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList) &#123;</span><br><span class="line">       <span class="keyword">int</span> length = beginWord.length();</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; result;</span><br><span class="line">   <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; wordSet(wordList.begin(), wordList.end());</span><br><span class="line">   <span class="keyword">if</span>(wordSet.count(endWord) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   wordSet.erase(beginWord);</span><br><span class="line">   <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; q1;</span><br><span class="line">   q1.insert(beginWord);</span><br><span class="line"></span><br><span class="line">   wordSet.erase(endWord);</span><br><span class="line">   <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; q2;</span><br><span class="line">   q2.insert(endWord);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; parents;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">bool</span> isLeft = <span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">while</span>(!q1.empty() &amp;&amp; !q2.empty() &amp;&amp; !found) &#123;</span><br><span class="line">   <span class="keyword">if</span>(q1.size() &gt; q2.size()) &#123;</span><br><span class="line">   swap(q1, q2);</span><br><span class="line">   isLeft = !isLeft;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line">   <span class="keyword">for</span>(<span class="built_in">string</span> s : q1) &#123;</span><br><span class="line">   <span class="built_in">string</span> origin = s;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">   <span class="keyword">char</span> old = s[i];</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="string">'a'</span>; k &lt;= <span class="string">'z'</span>; k++) &#123;</span><br><span class="line">   <span class="keyword">if</span>(k == old) &#123;</span><br><span class="line">   <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   s[i] = k;</span><br><span class="line">   <span class="keyword">if</span>(q2.count(s) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   found = <span class="literal">true</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span>(wordSet.count(s) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   q.insert(s);</span><br><span class="line">   <span class="keyword">if</span>(isLeft) &#123;</span><br><span class="line">   parents[s].push_back(origin);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   parents[origin].push_back(s);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   s[i] = old;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   swap(q1, q);</span><br><span class="line">   <span class="keyword">for</span>(<span class="built_in">string</span> s : q1) &#123;</span><br><span class="line">   wordSet.erase(s);</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(!found) &#123;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; acc;</span><br><span class="line">   acc.push_back(endWord);</span><br><span class="line">   dfs(result, beginWord, endWord, parents, acc);</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; &amp;result, <span class="built_in">string</span> &amp;beginWord, <span class="built_in">string</span> &amp;currentWord, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; &amp;parents, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;acc)</span> </span>&#123;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt;::const_iterator got = parents.find(currentWord);</span><br><span class="line"><span class="keyword">if</span>(got == parents.end()) &#123;</span><br><span class="line"><span class="keyword">if</span>(acc[acc.size() - <span class="number">1</span>] == beginWord) &#123;</span><br><span class="line">result.push_back(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(acc.rbegin(), acc.rend()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">string</span> s : got-&gt;second) &#123;</span><br><span class="line">acc.push_back(s);</span><br><span class="line">dfs(result, beginWord, s, parents, acc);</span><br><span class="line">acc.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>127. Word Ladder</title>
      <link href="/2020/01/17/leetecode/127-Word-Ladder/"/>
      <url>/2020/01/17/leetecode/127-Word-Ladder/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定两个字符串，分别为beginWord，endWord, 和一个词典。求beginWord转换到endWord字符串的最短路径。要求每次只能改变一个字符，并且改变后的字符串必须包含在词典里面。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>直接用<a href="https://zxi.mytechroad.com/blog/searching/127-word-ladder/" target="_blank" rel="noopener">花花酱</a>的双向遍历的方法。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-实现代码"><a href="#C-实现代码" class="headerlink" title="C++实现代码"></a>C++实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> length = beginWord.length();</span><br><span class="line">   <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; wordSet(wordList.begin(), wordList.end());</span><br><span class="line">   <span class="keyword">if</span>(wordSet.count(endWord) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; q1;</span><br><span class="line">   q1.insert(beginWord);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; q2;</span><br><span class="line">   q2.insert(endWord);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(!q1.empty() &amp;&amp; !q2.empty()) &#123;</span><br><span class="line">   <span class="keyword">if</span>(q1.size() &gt; q2.size()) &#123;</span><br><span class="line">   swap(q1, q2);</span><br><span class="line">   &#125;</span><br><span class="line">   result++;</span><br><span class="line">   <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line">   <span class="keyword">for</span>(<span class="built_in">string</span> s : q1) &#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">   <span class="keyword">char</span> old = s[i];</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="string">'a'</span>; k &lt;= <span class="string">'z'</span>; k++) &#123;</span><br><span class="line">   s[i] = k;</span><br><span class="line">   <span class="keyword">if</span>(q2.count(s) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> result + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(wordSet.count(s) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   wordSet.erase(s);</span><br><span class="line">   q.insert(s);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   s[i] = old;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   swap(q1, q);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>218. The Skyline Problem</title>
      <link href="/2020/01/16/leetecode/218-The-Skyline-Problem/"/>
      <url>/2020/01/16/leetecode/218-The-Skyline-Problem/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>可以看<a href="https://www.bilibili.com/video/av65110529?t=1002" target="_blank" rel="noopener">山景城一姐</a>的题意解释。给定一些三元组，每个三元组分别表示每个建筑物的左边的橫坐标，右边的橫坐标，和建筑物的高度。要求画出这些建筑物的轮廓。把这些轮廓的产生的线段最左边的位置给输出。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>完全是参考<a href="https://www.bilibili.com/video/av65110529?t=1002" target="_blank" rel="noopener">山景城一姐</a>，讲得很清晰。想象为一个画笔沿着建筑物描线段，用一个大根堆来保存当前扫描到的建筑物的高度，用一个变量来保存当前的高度，也即画笔停留的高度。当扫描到一个建筑物的边缘时，如果是建筑物左边就把这高度压到大根堆中，若是建筑物右边，就把这个建筑物对应的高度从大根堆里面删除。然后在看大根堆里面保存的最大高度是否跟画笔停留的水平线产生高度差，如果产生，就是需要输出的点。这个题目的难点在于需要自己实现一个大根堆。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-实现代码"><a href="#C-实现代码" class="headerlink" title="C++实现代码"></a>C++实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">int</span> pos;</span><br><span class="line"><span class="keyword">int</span> height;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapElement</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">int</span> h;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Segment&amp; a, <span class="keyword">const</span> Segment&amp; b) &#123;</span><br><span class="line"><span class="keyword">if</span>(a.pos == b.pos) &#123;</span><br><span class="line"><span class="keyword">return</span> a.height &lt; b.height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a.pos &lt; b.pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MaxHeap(<span class="keyword">int</span> maxSize):elements(maxSize), idx(maxSize), size(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> elements[<span class="number">0</span>].h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> _idx = size;</span><br><span class="line"><span class="keyword">int</span> parent = ((_idx + <span class="number">1</span>) / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">//up</span></span><br><span class="line"><span class="keyword">while</span>(parent &gt;= <span class="number">0</span> &amp;&amp; elements[parent].h &lt; value) &#123;</span><br><span class="line">elements[_idx] = elements[parent];</span><br><span class="line">idx[elements[parent].id] = _idx;</span><br><span class="line"></span><br><span class="line">_idx = parent;</span><br><span class="line">parent = ((_idx + <span class="number">1</span>) / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">elements[_idx] = (HeapElement)&#123;id, value&#125;;</span><br><span class="line">idx[id] = _idx;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> heapIdx = idx[id];</span><br><span class="line">idx[id] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">HeapElement element = elements[size - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//down</span></span><br><span class="line"><span class="keyword">int</span> right = (heapIdx + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> left = right - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> index = right;</span><br><span class="line"><span class="keyword">if</span>(right &gt;= size || elements[left].h &gt; elements[right].h) &#123;</span><br><span class="line">index = left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(index &lt; size &amp;&amp; element.h &lt; elements[index].h) &#123;</span><br><span class="line">idx[elements[index].id] = heapIdx;</span><br><span class="line">elements[heapIdx] = elements[index];</span><br><span class="line"></span><br><span class="line">heapIdx = index;</span><br><span class="line">right = (index + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">left = right - <span class="number">1</span>;</span><br><span class="line">index = right;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(right &gt;= size || elements[left].h &gt; elements[right].h) &#123;</span><br><span class="line">index = left;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">idx[element.id] = heapIdx;</span><br><span class="line">elements[heapIdx] = element;</span><br><span class="line">size--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;HeapElement&gt; elements;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; idx;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; getSkyline(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; buildings) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; result;</span><br><span class="line"><span class="built_in">vector</span>&lt;Segment&gt; segments;</span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;::iterator it = buildings.begin(); it != buildings.end(); it++) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; item = *it;</span><br><span class="line">segments.push_back((Segment)&#123;idx, item[<span class="number">0</span>], -item[<span class="number">2</span>]&#125;);</span><br><span class="line">segments.push_back((Segment)&#123;idx, item[<span class="number">1</span>], item[<span class="number">2</span>]&#125;);</span><br><span class="line">idx++;</span><br><span class="line">&#125;</span><br><span class="line">sort(segments.begin(), segments.end());</span><br><span class="line"><span class="function">MaxHeap <span class="title">maxHeap</span><span class="params">(buildings.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">maxHeap.add(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> currentHeight = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;Segment&gt;::iterator it = segments.begin(); it != segments.end(); it++) &#123;</span><br><span class="line"><span class="keyword">int</span> height = it-&gt;height;</span><br><span class="line"><span class="keyword">int</span> pos = it-&gt;pos;</span><br><span class="line"><span class="keyword">int</span> id = it-&gt;id;</span><br><span class="line"><span class="keyword">if</span>(height &lt; <span class="number">0</span>) &#123;</span><br><span class="line">maxHeap.add(-height, id);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">maxHeap.remove(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> heapTop = maxHeap.top();</span><br><span class="line"><span class="keyword">if</span>(heapTop != currentHeight) &#123;</span><br><span class="line">currentHeight = heapTop;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; item(<span class="number">2</span>);</span><br><span class="line">item[<span class="number">0</span>] = pos;</span><br><span class="line">item[<span class="number">1</span>] = currentHeight;</span><br><span class="line">result.push_back(item);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>730. Count Different Palindromic Subsequences</title>
      <link href="/2019/12/24/leetecode/730-Count-Different-Palindromic-Subsequences/"/>
      <url>/2019/12/24/leetecode/730-Count-Different-Palindromic-Subsequences/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个字符串S，需要你求出一共有多少个子串可以组成回文串，这些回文串不能重复，可以不连续，但是需要保持在S中的相对位置。<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>是参考<a href="https://zxi.mytechroad.com/blog/dynamic-programming/leetcode-730-count-different-palindromic-subsequences/" target="_blank" rel="noopener">花花酱</a>的解题方法，这里有他对这题详细讲解的<a href="https://www.bilibili.com/video/av32068633?from=search&amp;seid=15612238682544070455" target="_blank" rel="noopener">视频</a>,讲得很详细清楚。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-实现代码"><a href="#C-实现代码" class="headerlink" title="C++实现代码"></a>C++实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPalindromicSubsequences</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> kMod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">if</span>(S.length() == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(S.length(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(S.length(), <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++) &#123;</span><br><span class="line">dp[i][i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= S.length(); k++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length() &amp;&amp; i + k &lt; S.length(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(S[i] == S[i + k]) &#123;</span><br><span class="line"><span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> right = i + k - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(left &lt;= right &amp;&amp; S[i] != S[left]) &#123;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(right &gt;= left &amp;&amp; S[i] != S[right]) &#123;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(left &gt; right) &#123;</span><br><span class="line">dp[i][i + k] = <span class="number">2</span> * dp[i + <span class="number">1</span>][i + k - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(left == right) &#123;</span><br><span class="line">dp[i][i + k] = <span class="number">2</span> * dp[i + <span class="number">1</span>][i + k - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][i + k] = <span class="number">2</span> * dp[i + <span class="number">1</span>][i + k - <span class="number">1</span>] - dp[left + <span class="number">1</span>][right - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][i + k] = dp[i][i + k - <span class="number">1</span>] + dp[i + <span class="number">1</span>][i + k] - dp[i + <span class="number">1</span>][i + k - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">dp[i][i + k] = (dp[i][i + k] + kMod) % kMod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][S.length() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Go实现代码"><a href="#Go实现代码" class="headerlink" title="Go实现代码"></a>Go实现代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countPalindromicSubsequences</span><span class="params">(S <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="built_in">len</span>(S))</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> S &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(S))</span><br><span class="line"><span class="keyword">for</span> j := <span class="keyword">range</span> S &#123;</span><br><span class="line">dp[i][j] = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">dp[i][i] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kMod := <span class="number">1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k := <span class="number">1</span>; k &lt; <span class="built_in">len</span>(S); k++ &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i + k &lt; <span class="built_in">len</span>(S) &amp;&amp; i &lt; <span class="built_in">len</span>(S); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> S[i] == S[i + k] &#123;</span><br><span class="line">left := i + <span class="number">1</span></span><br><span class="line">right := i + k - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> left &lt;= right &amp;&amp; S[i] != S[left] &#123;</span><br><span class="line">left++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> right &gt;= left &amp;&amp; S[i] != S[right] &#123;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> left &gt; right &#123;</span><br><span class="line">dp[i][i + k] = <span class="number">2</span> * dp[i + <span class="number">1</span>][i + k - <span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> left == right &#123;</span><br><span class="line">dp[i][i + k] = <span class="number">2</span> * dp[i + <span class="number">1</span>][i + k - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][i + k] = <span class="number">2</span> * dp[i + <span class="number">1</span>][i + k - <span class="number">1</span>] - dp[left + <span class="number">1</span>][right - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][i + k] = dp[i + <span class="number">1</span>][i + k] + dp[i][i + k - <span class="number">1</span>] - dp[i + <span class="number">1</span>][i + k - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dp[i][i + k] = (dp[i][i + k] + kMod) % kMod</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][<span class="built_in">len</span>(S) - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1147. Longest Chunked Palindrome Decomposition</title>
      <link href="/2019/12/23/leetecode/1147-Longest-Chunked-Palindrome-Decomposition/"/>
      <url>/2019/12/23/leetecode/1147-Longest-Chunked-Palindrome-Decomposition/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个字符串s，对其进行切分，切分后一共有k的段。要求最大的k，使得以段为一个单位来看，能够形成一个回文段。例如text = “ghiabcdefhelloadamhelloabcdefghi”，切分为7段，”(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)”，把段看成一个单位，形成一个回文段。<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>贪心法递归，当子串s[0:k]与s[len - k: len]相等时，递归求子串s[k:len-k]能够形成回文段的最大段数，将这个段数加2，既为整个串的最大段数。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-实现代码"><a href="#C-实现代码" class="headerlink" title="C++实现代码"></a>C++实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestDecomposition</span><span class="params">(<span class="built_in">string</span> text)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(text.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= text.length() / <span class="number">2</span>; k++) &#123;</span><br><span class="line"><span class="keyword">if</span>(text.substr(<span class="number">0</span>, k) == text.substr(text.length() - k)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> + longestDecomposition(text.substr(k, text.length() - <span class="number">2</span> * k));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Go实现代码"><a href="#Go实现代码" class="headerlink" title="Go实现代码"></a>Go实现代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestDecomposition</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(text) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k := <span class="number">1</span>; k &lt;= <span class="built_in">len</span>(text) / <span class="number">2</span>; k++ &#123;</span><br><span class="line"><span class="keyword">if</span> text[<span class="number">0</span>:k] == text[<span class="built_in">len</span>(text) - k:<span class="built_in">len</span>(text)] &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> + longestDecomposition(text[k:<span class="built_in">len</span>(text) - k])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>906. Super Palindromes</title>
      <link href="/2019/12/17/leetecode/906-Super-Palindromes/"/>
      <url>/2019/12/17/leetecode/906-Super-Palindromes/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个数字区间[L, R]，在这个区间内都所有数，哪些数字是回文数字串，并且这个数字的开根号得到的结果，也是一个回文数字串。求满足条件的这种数字的个数。例如 L = “4”, R = “1000”, 4 = 2 * 2, 9 = 3 * 3, 121 = 11 * 11, 484 = 22 * 22。一共有4个。<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>用暴利穷举法，由于L和R都是小于10^18，所以它们的开根号R &lt; 10^9。而R需要是一个回文数字串，假设R由k|k’拼接而成，其中k’为k的反转数字串。由于R &lt; 10^9, 所以k &lt; 10^5。因此 1 &lt;= k &lt; 10^5，穷举R，看是否满足条件。这里拼接成R需要分奇数长度和偶数长度，例如k = 1234,那么R可以为1234321和12344321。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-实现代码"><a href="#C-实现代码" class="headerlink" title="C++实现代码"></a>C++实现代码</h2> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">superpalindromesInRange</span><span class="params">(<span class="built_in">string</span> L, <span class="built_in">string</span> R)</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span>::size_type sz = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> l = stoll(L, &amp;sz, <span class="number">0</span>);</span><br><span class="line">sz = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> r = stoll(R, &amp;sz, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> MAGIC = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> lsqrt = <span class="built_in">sqrt</span>((<span class="keyword">double</span>)l);</span><br><span class="line"></span><br><span class="line"><span class="comment">// odd length</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; MAGIC; k++) &#123;</span><br><span class="line"><span class="built_in">string</span> s = to_string(k);</span><br><span class="line"><span class="keyword">if</span>(s.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">string</span> sub = s.substr(<span class="number">0</span>, s.size() - <span class="number">1</span>);</span><br><span class="line">reverse(sub.begin(), sub.end());</span><br><span class="line">s += sub;</span><br><span class="line">&#125;</span><br><span class="line">sz = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> num = stoll(s, &amp;sz, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(num &lt; lsqrt) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">num *= num;</span><br><span class="line"><span class="keyword">if</span>(num &gt; r) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isPalindrome(num)) &#123;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; MAGIC; k++) &#123;</span><br><span class="line"><span class="built_in">string</span> s = to_string(k);</span><br><span class="line"><span class="built_in">string</span> rs = s;</span><br><span class="line">reverse(rs.begin(), rs.end());</span><br><span class="line">s += rs;</span><br><span class="line">sz = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> num = stoll(s, &amp;sz, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(num &lt; lsqrt) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">num *= num;</span><br><span class="line"><span class="keyword">if</span>(num &gt; r) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isPalindrome(num)) &#123;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> x_temp = x;</span><br><span class="line"><span class="keyword">while</span>(x_temp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">ans = <span class="number">10</span> * ans + (x_temp % <span class="number">10</span>);</span><br><span class="line">x_temp /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans == x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Go实现代码"><a href="#Go实现代码" class="headerlink" title="Go实现代码"></a>Go实现代码</h2> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> <span class="string">"strconv"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">superpalindromesInRange</span><span class="params">(L <span class="keyword">string</span>, R <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">l, _ := strconv.ParseInt(L, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">r, _ := strconv.ParseInt(R, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">MAGIC := <span class="number">100000</span></span><br><span class="line"></span><br><span class="line">ans := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="number">1</span>; k &lt; MAGIC; k++ &#123;</span><br><span class="line">s := strconv.Itoa(k)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) &gt;= <span class="number">2</span> &#123;</span><br><span class="line">s += reverse(s[<span class="number">0</span>:<span class="built_in">len</span>(s) - <span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">num, _ := strconv.ParseInt(s, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">num *= num</span><br><span class="line"><span class="keyword">if</span> num &gt; r &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> num &gt;= l &amp;&amp; isPalindromes(num) &#123;</span><br><span class="line">ans += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k := <span class="number">1</span>; k &lt; MAGIC; k++ &#123;</span><br><span class="line">s := strconv.Itoa(k)</span><br><span class="line">s += reverse(s)</span><br><span class="line"></span><br><span class="line">num, _ := strconv.ParseInt(s, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">num *= num</span><br><span class="line"><span class="keyword">if</span> num &gt; r &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> num &gt;= l &amp;&amp; isPalindromes(num) &#123;</span><br><span class="line">ans += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">runes := []<span class="keyword">rune</span>(s)</span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(runes)<span class="number">-1</span>; i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">runes[i], runes[j] = runes[j], runes[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(runes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindromes</span><span class="params">(s <span class="keyword">int64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">ans := <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line">s_temp := s</span><br><span class="line"><span class="keyword">for</span> s_temp &gt; <span class="number">0</span> &#123;</span><br><span class="line">ans = ans * <span class="number">10</span> + s_temp % <span class="number">10</span></span><br><span class="line">s_temp /= <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans == s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>336. Palindrome Pairs</title>
      <link href="/2019/12/15/leetecode/336-Palindrome-Pairs/"/>
      <url>/2019/12/15/leetecode/336-Palindrome-Pairs/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给以一些字符串，从中找出所有的pair对，每组pair对能形成一个回文串<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>解题的方法参照这篇<a href="https://segmentfault.com/a/1190000008917798" target="_blank" rel="noopener">博客</a></p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-实现代码"><a href="#C-实现代码" class="headerlink" title="C++实现代码"></a>C++实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; palindromePairs(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; dic;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator it = words.begin(); it != words.end(); it++) &#123;</span><br><span class="line">dic[*it] = index++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.size(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= words[i].size(); k++) &#123;</span><br><span class="line"><span class="built_in">string</span> prefix = words[i].substr(<span class="number">0</span>, k);</span><br><span class="line"><span class="built_in">string</span> prefixRev;</span><br><span class="line">prefixRev.assign(prefix.rbegin(), prefix.rend());</span><br><span class="line"><span class="built_in">string</span> suffix = words[i].substr(k);</span><br><span class="line"><span class="built_in">string</span> suffixRev;</span><br><span class="line">suffixRev.assign(suffix.rbegin(), suffix.rend());</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator p_iter = dic.find(prefixRev);</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator s_iter = dic.find(suffixRev);</span><br><span class="line"><span class="keyword">if</span>(isPalindrome(prefix) &amp;&amp; s_iter != dic.end() &amp;&amp; s_iter-&gt;second != i) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(s_iter-&gt;second);</span><br><span class="line">v.push_back(i);</span><br><span class="line">result.push_back(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(suffix.size() != <span class="number">0</span> &amp;&amp; isPalindrome(suffix) &amp;&amp; p_iter != dic.end() &amp;&amp; p_iter-&gt;second != i) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(i);</span><br><span class="line">v.push_back(p_iter-&gt;second);</span><br><span class="line">result.push_back(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s.empty()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = s.size() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line"><span class="keyword">if</span>(s[left] != s[right]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">left++;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Go实现代码"><a href="#Go实现代码" class="headerlink" title="Go实现代码"></a>Go实现代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">palindromePairs</span><span class="params">(words []<span class="keyword">string</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">dic := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">for</span> index, word := <span class="keyword">range</span> words &#123;</span><br><span class="line">dic[word] = index</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result [][]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, word := <span class="keyword">range</span> words &#123;</span><br><span class="line"><span class="keyword">for</span> k := <span class="number">0</span>; k &lt;= <span class="built_in">len</span>(word); k++ &#123;</span><br><span class="line">prefix := word[<span class="number">0</span>:k]</span><br><span class="line">prefix_rev := reverse(prefix)</span><br><span class="line">suffix := word[k:]</span><br><span class="line">suffix_rev := reverse(suffix)</span><br><span class="line"><span class="keyword">if</span> isPalindrome(prefix) &#123;</span><br><span class="line">i, ok := dic[suffix_rev]</span><br><span class="line"><span class="keyword">if</span> ok &amp;&amp; i != index &#123;</span><br><span class="line">r := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">r[<span class="number">0</span>] = i</span><br><span class="line">r[<span class="number">1</span>] = index</span><br><span class="line">result = <span class="built_in">append</span>(result, r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(suffix) != <span class="number">0</span> &amp;&amp; isPalindrome(suffix) &#123;</span><br><span class="line">i, ok := dic[prefix_rev]</span><br><span class="line"><span class="keyword">if</span> ok &amp;&amp; i != index &#123;</span><br><span class="line">r := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">r[<span class="number">0</span>] = index</span><br><span class="line">r[<span class="number">1</span>] = i</span><br><span class="line">result = <span class="built_in">append</span>(result, r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(word <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(word) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(word) - <span class="number">1</span>; i &lt; j; i, j = i + <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">if</span> word[i] != word[j] &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    runes := []<span class="keyword">rune</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(runes) - <span class="number">1</span>; i &lt; j; i, j = i + <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line">        runes[i], runes[j] = runes[j], runes[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(runes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1278. Palindrome Partitioning III</title>
      <link href="/2019/12/12/leetecode/1278-Palindrome-Partitioning-III/"/>
      <url>/2019/12/12/leetecode/1278-Palindrome-Partitioning-III/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个字符串s, 和一个数值k,要求你对s进行切分，切分为k段。对这k个子串进行修改，使得每个子串都为回文串。求需要修改的最小次数。<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>动态规划，用cost[i][j]表示s的子串[i, j]要成为回文串需要做多少次修改。<br>dp[i][k]表示将s的子串[0, i]分成k个子串，每个子串都为回文串，所需要的最小修改次数。<br>所以dp[i][k] = min(dp[i][k], dp[j][k - 1] + cost[j + 1][i]),其中0&lt;= j &lt; i。<br>初始化dp[i][1] = cost[0][i]，表示分成1个分组时候，需要改变多少次，保证这个分组子串是回文串。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-实现代码"><a href="#C-实现代码" class="headerlink" title="C++实现代码"></a>C++实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">palindromePartition</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; cost(s.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(s.size(), <span class="number">0</span>));</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(s.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(k, <span class="number">-1</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>; l &lt; s.size(); l++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = i + l; j &lt; s.size(); i++, j++) &#123;</span><br><span class="line">cost[i][j] = (s[i] != s[j]) + cost[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = cost[<span class="number">0</span>][i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> g = <span class="number">1</span>; g &lt; k; g++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i &gt;= g &amp;&amp; j &gt;= g - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(dp[i][g] == <span class="number">-1</span>) &#123;</span><br><span class="line">dp[i][g] = dp[j][g - <span class="number">1</span>] + cost[j + <span class="number">1</span>][i];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][g] = min(dp[i][g], dp[j][g - <span class="number">1</span>] + cost[j + <span class="number">1</span>][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][g] = cost[<span class="number">0</span>][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[s.size() - <span class="number">1</span>][k - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Go实习代码"><a href="#Go实习代码" class="headerlink" title="Go实习代码"></a>Go实习代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">palindromePartition</span><span class="params">(s <span class="keyword">string</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">cost := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="built_in">len</span>(s))</span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="built_in">len</span>(s))</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> s &#123;</span><br><span class="line">cost[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(s))</span><br><span class="line">cost[i][i] = <span class="number">0</span></span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, k)</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; k; j++ &#123;</span><br><span class="line">dp[i][j] = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> l := <span class="number">1</span>; l &lt; <span class="built_in">len</span>(s); l++ &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i + l &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">j := i + l</span><br><span class="line"><span class="keyword">if</span> l &lt;= <span class="number">1</span> &#123;</span><br><span class="line">cost[i][j] = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> s[i] != s[j] &#123;</span><br><span class="line">cost[i][j] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cost[i][j] = cost[i + <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> s[i] != s[j] &#123;</span><br><span class="line">cost[i][j] += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = cost[<span class="number">0</span>][i]</span><br><span class="line"><span class="keyword">for</span> g := <span class="number">1</span>; g &lt; k; g++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> i &gt;= g &amp;&amp; j &gt;= g - <span class="number">1</span> &#123;</span><br><span class="line">ans := dp[j][g - <span class="number">1</span>] + cost[j + <span class="number">1</span>][i]</span><br><span class="line"><span class="keyword">if</span> dp[i][g] == <span class="number">-1</span> &#123;</span><br><span class="line">dp[i][g] = ans</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> dp[i][g] &gt; ans &#123;</span><br><span class="line">dp[i][g] = ans</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][g] = cost[<span class="number">0</span>][i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="built_in">len</span>(s) - <span class="number">1</span>][k - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>132. Palindrome Partitioning II</title>
      <link href="/2019/12/11/leetecode/132-Palindrome-Partitioning-II/"/>
      <url>/2019/12/11/leetecode/132-Palindrome-Partitioning-II/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个字符串s，求最小的切分数，保证切分完的每次子串都是回文串。<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>用动态规划dp[i]表示[i, len(s))子串最少的回文串数。<br>如果[i, j]范围的子串为回文串，那么dp[i] = min(dp[i], dp[j + 1] + 1);<br>否则dp[i] = dp[i - 1] + 1.<br>字符串从右往左扫描时用isPalindrome[i][j]表示范围[i, j] 是否为回文串。<br>如果isPalindrome[i + 1][j -1]为true，且s[i] == s[j],则isPalindrome[i][j]为true.</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-实现代码"><a href="#C-实现代码" class="headerlink" title="C++实现代码"></a>C++实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCut</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; isPalindrome(s.size(), <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(s.size(), <span class="literal">false</span>));</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(s.size(), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = s.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">isPalindrome[i][i] = <span class="literal">true</span>;</span><br><span class="line">dp[i] = i &lt; s.size() - <span class="number">1</span> ? dp[i + <span class="number">1</span>] + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; s.size(); j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(s[i] == s[j] &amp;&amp; (j - i &lt;= <span class="number">2</span> || isPalindrome[i + <span class="number">1</span>][j - <span class="number">1</span>])) &#123;</span><br><span class="line">isPalindrome[i][j] = <span class="literal">true</span>;</span><br><span class="line">dp[i] = min(dp[i], j &lt; s.size() - <span class="number">1</span> ? dp[j + <span class="number">1</span>] + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Go实现代码"><a href="#Go实现代码" class="headerlink" title="Go实现代码"></a>Go实现代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minCut</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">isPalindrome := <span class="built_in">make</span>([][]<span class="keyword">bool</span>, <span class="built_in">len</span>(s))</span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(s))</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> s &#123;</span><br><span class="line">isPalindrome[i] = <span class="built_in">make</span>([]<span class="keyword">bool</span>, <span class="built_in">len</span>(s))</span><br><span class="line">dp[i] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="keyword">range</span> s &#123;</span><br><span class="line"><span class="keyword">if</span> i == j &#123;</span><br><span class="line">isPalindrome[i][j] = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">isPalindrome[i][j] = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(s) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line"><span class="keyword">if</span> i &lt; <span class="built_in">len</span>(s) - <span class="number">1</span> &#123;</span><br><span class="line">dp[i] = dp[i + <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(s); j++ &#123;</span><br><span class="line"><span class="keyword">if</span> s[i] == s[j] &amp;&amp; (j - i &lt;= <span class="number">2</span> || isPalindrome[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123;</span><br><span class="line">isPalindrome[i][j] = <span class="literal">true</span></span><br><span class="line">ans := <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> j &lt; <span class="built_in">len</span>(s) - <span class="number">1</span> &#123;</span><br><span class="line">ans = dp[j + <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> dp[i] &gt; ans &#123;</span><br><span class="line">dp[i] = ans</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>] - <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>131. Palindrome Partitioning</title>
      <link href="/2019/12/11/leetecode/131-Palindrome-Partitioning/"/>
      <url>/2019/12/11/leetecode/131-Palindrome-Partitioning/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个字符串s，对这个字符串s做切分，使得切分后的子串都是回文串。要求把所有的切分情况输出。<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>递归求解，用一个数组isPalindrome来记录遍历的情况。isPalindrome[i][j]初始为-1，表示还没有遍历。为1表示子串si~sj是个回文子串。为0则表示该子串不是回文。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-实现代码"><a href="#C-实现代码" class="headerlink" title="C++实现代码"></a>C++实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition(<span class="built_in">string</span> s) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; isPalindrome(s.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(s.size(), <span class="number">-1</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">isPalindrome[i][i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; results;</span><br><span class="line">assist(s, <span class="number">0</span>, isPalindrome, strs, results);</span><br><span class="line"><span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assist</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> startIndex, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;isPalindrome, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;strs, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;results)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(startIndex &gt;= s.size()) &#123;</span><br><span class="line"><span class="keyword">if</span>(!strs.empty()) &#123;</span><br><span class="line">results.push_back(strs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span>; startIndex + len &lt;= s.size(); len++) &#123;</span><br><span class="line"><span class="keyword">if</span>(isPalindrome[startIndex][startIndex + len - <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(isPalindrome[startIndex][startIndex + len - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">strs.push_back(s.substr(startIndex, len));</span><br><span class="line">assist(s, startIndex + len, isPalindrome, strs, results);</span><br><span class="line">strs.pop_back();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(s[startIndex] == s[startIndex + len - <span class="number">1</span>] &amp;&amp; (len == <span class="number">2</span> || isPalindrome[startIndex + <span class="number">1</span>][startIndex + len - <span class="number">2</span>] == <span class="number">1</span>)) &#123;</span><br><span class="line">isPalindrome[startIndex][startIndex + len - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">strs.push_back(s.substr(startIndex, len));</span><br><span class="line">assist(s, startIndex + len, isPalindrome, strs, results);</span><br><span class="line">strs.pop_back();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">isPalindrome[startIndex][startIndex + len - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Go实现代码"><a href="#Go实现代码" class="headerlink" title="Go实现代码"></a>Go实现代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(s <span class="keyword">string</span>)</span> [][]<span class="title">string</span></span> &#123;</span><br><span class="line">results := [][]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">isPalindrome := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="built_in">len</span>(s))</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> s &#123;</span><br><span class="line">isPalindrome[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(s))</span><br><span class="line"><span class="keyword">for</span> j := <span class="keyword">range</span> s &#123;</span><br><span class="line"><span class="keyword">if</span> i == j &#123;</span><br><span class="line">isPalindrome[i][j] = <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">isPalindrome[i][j] = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">strs := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">assist(s, <span class="number">0</span>, isPalindrome, &amp;strs, &amp;results)</span><br><span class="line"><span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assist</span><span class="params">(s <span class="keyword">string</span>, startIndex <span class="keyword">int</span>, isPalindrome [][]<span class="keyword">int</span>, strs *[]<span class="keyword">string</span>, results *[][]<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> startIndex &gt;= <span class="built_in">len</span>(s) &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(*strs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">tmp := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(*strs))</span><br><span class="line"><span class="built_in">copy</span>(tmp, *strs)</span><br><span class="line">*results = <span class="built_in">append</span>(*results, tmp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i_len := <span class="number">1</span>; startIndex + i_len &lt;= <span class="built_in">len</span>(s); i_len++ &#123;</span><br><span class="line"><span class="keyword">if</span> isPalindrome[startIndex][startIndex + i_len - <span class="number">1</span>] == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> isPalindrome[startIndex][startIndex + i_len - <span class="number">1</span>] == <span class="number">1</span> &#123;</span><br><span class="line">*strs = <span class="built_in">append</span>(*strs, s[startIndex:startIndex + i_len])</span><br><span class="line">assist(s, startIndex + i_len, isPalindrome, strs, results)</span><br><span class="line">*strs = (*strs)[:<span class="built_in">len</span>(*strs) - <span class="number">1</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> s[startIndex] == s[startIndex + i_len - <span class="number">1</span>] &amp;&amp; (i_len == <span class="number">2</span> || isPalindrome[startIndex + <span class="number">1</span>][startIndex + i_len - <span class="number">2</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">isPalindrome[startIndex][startIndex + i_len - <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">*strs = <span class="built_in">append</span>(*strs, s[startIndex:startIndex + i_len])</span><br><span class="line">assist(s, startIndex + i_len, isPalindrome, strs, results)</span><br><span class="line">*strs = (*strs)[:<span class="built_in">len</span>(*strs) - <span class="number">1</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">isPalindrome[startIndex][startIndex + i_len - <span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>214. Shortest Palindrome</title>
      <link href="/2019/12/10/leetecode/214-Shortest-Palindrome/"/>
      <url>/2019/12/10/leetecode/214-Shortest-Palindrome/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个字符串s，通过在这个字符串s前面一串最短字符串，使其成为一个回文串。<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>用KMP算法来求解，可以得到O(n)的时间复杂度。将s串反转的reverse_s，使reverse_s为主串，s为模式串，利用kmp算法来求解。求得s模式串在reverse_s中匹配的最大长度，将reverse_s尾部截断这部分长度和s拼接，求得最终解。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-实现代码"><a href="#C-实现代码" class="headerlink" title="C++实现代码"></a>C++实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">shortestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">revs</span><span class="params">(s)</span></span>;</span><br><span class="line">reverse(revs.begin(), revs.end());</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next(s.size(), <span class="number">-1</span>);</span><br><span class="line">getNextArray(s, next);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> revsSize = revs.size();</span><br><span class="line"><span class="keyword">int</span> sSize = s.size();</span><br><span class="line"><span class="keyword">while</span>(i &lt; revsSize  &amp;&amp; j &lt; sSize) &#123;</span><br><span class="line"><span class="keyword">if</span>(j == <span class="number">-1</span> || revs[i] == s[j]) &#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">j = next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(j &gt;= s.size()) &#123;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> revs.substr(<span class="number">0</span>, s.size() - j) + s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNextArray</span><span class="params">(<span class="built_in">string</span> &amp;p, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;next)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; p.size()) &#123;</span><br><span class="line"><span class="keyword">if</span>(k == <span class="number">-1</span> || p[i] == p[k]) &#123;</span><br><span class="line">k++;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span>(i &lt; p.size()) &#123;</span><br><span class="line">next[i] = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">k = next[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Go实现代码"><a href="#Go实现代码" class="headerlink" title="Go实现代码"></a>Go实现代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shortestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line">next := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(s))</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line">revs := reverse(s)</span><br><span class="line"></span><br><span class="line">getNext(s, next)</span><br><span class="line"></span><br><span class="line">i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="built_in">len</span>(revs) &amp;&amp; j &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">-1</span> || revs[i] == s[j] &#123;</span><br><span class="line">i++</span><br><span class="line">j++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">j = next[j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> j == <span class="built_in">len</span>(revs) &#123;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> revs[<span class="number">0</span>:<span class="built_in">len</span>(s) - j] + s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">r := []<span class="keyword">rune</span>(s)</span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(r)<span class="number">-1</span>; i &lt; <span class="built_in">len</span>(r) / <span class="number">2</span>; i, j = i + <span class="number">1</span>, j - <span class="number">1</span> &#123;</span><br><span class="line">r[i], r[j] = r[j], r[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNext</span><span class="params">(s <span class="keyword">string</span>, next []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line">k := <span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line"><span class="keyword">if</span> k == <span class="number">-1</span> || s[i] == s[k] &#123;</span><br><span class="line">k++</span><br><span class="line">i++</span><br><span class="line"><span class="keyword">if</span> i &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">next[i] = k</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">k = next[k]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>212. Word Search II</title>
      <link href="/2019/12/09/leetecode/212-Word-Search-II/"/>
      <url>/2019/12/09/leetecode/212-Word-Search-II/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>这道题跟<a href="https://daxiaoluo.github.io/2019/12/08/leetecode/79-Word-Search/" target="_blank" rel="noopener">Word Search</a>这题很像。不同的是Word Search对给定一个字符串，判断它是否在字符矩阵里。而本题是给定一批字符串，需要输出在字符矩阵里面的字符串集合。<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>如果有暴露搜索的方式，就是在Word Search的解法基础上，加一个循环遍历，分别判断每个字符串是否包含在这个字符矩阵里面。这种方法超时，过不了。所以按照<a href="https://www.cnblogs.com/grandyang/p/4516013.html" target="_blank" rel="noopener">这个方法</a>的思路。利用Tire树，将所有字符串存储到Tire树里面，然后遍历字符矩阵，以每格的字符开头，按水平和垂直方向深度遍历字符矩阵，看是否在Tire树中出现。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-实现代码"><a href="#C-实现代码" class="headerlink" title="C++实现代码"></a>C++实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">TrieNode *child[<span class="number">26</span>];</span><br><span class="line"><span class="built_in">string</span> *s;</span><br><span class="line">TrieNode(<span class="built_in">string</span> *str): s(str) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">child[i] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">TrieNode(): s(<span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">child[i] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">TrieNode *root;</span><br><span class="line">Trie() :root(<span class="keyword">new</span> TrieNode()) &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">TrieNode *p = root;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> index = s[i] - <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;child[index] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">p-&gt;child[index] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;child[index];</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;s = &amp;s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findWords(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">Trie trie;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator it = words.begin(); it != words.end(); it++) &#123;</span><br><span class="line">trie.insert(*it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited(board.size());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size(); i++) &#123;</span><br><span class="line">visited[i].resize(board[i].size());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[i].size(); j++) &#123;</span><br><span class="line">visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[i].size(); j++) &#123;</span><br><span class="line">visitBoard(board, i, j, trie.root, visited, result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visitBoard</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, TrieNode *node, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; visited, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;result)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= board.size() || j &lt; <span class="number">0</span> || j &gt;= board[i].size() || visited[i][j]) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = board[i][j] - <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span>(node-&gt;child[index] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">                TrieNode* p = node-&gt;child[index];</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;s != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    result.push_back(*(p-&gt;s));</span><br><span class="line">                    p-&gt;s = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">visitBoard(board, i + <span class="number">1</span>, j, p, visited, result);</span><br><span class="line">visitBoard(board, i - <span class="number">1</span>, j, p, visited, result);</span><br><span class="line">visitBoard(board, i, j + <span class="number">1</span>, p, visited, result);</span><br><span class="line">visitBoard(board, i, j - <span class="number">1</span>, p, visited, result);</span><br><span class="line">visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>79. Word Search</title>
      <link href="/2019/12/08/leetecode/79-Word-Search/"/>
      <url>/2019/12/08/leetecode/79-Word-Search/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个字符串s, 和一个字符矩阵board,要求判断这个字符串是否在这个字符矩阵之中。字符串s要求在这个字符矩阵中连续，连续是指方格横向和纵向领接。<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>简单的递归。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-实现代码"><a href="#C-实现代码" class="headerlink" title="C++实现代码"></a>C++实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited(board.size());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size(); i++) &#123;</span><br><span class="line">visited[i].resize(board[i].size());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[i].size(); j++) &#123;</span><br><span class="line">visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[i].size(); j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(visitBoard(board, i, j, word, <span class="number">0</span>, visited)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">visitBoard</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">string</span>&amp; word, <span class="keyword">int</span> index, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(index &gt;= word.size()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= board.size() || j &lt; <span class="number">0</span> || j &gt;= board[i].size() || visited[i][j]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(board[i][j] == word[index]) &#123;</span><br><span class="line">visited[i][j] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(visitBoard(board, i + <span class="number">1</span>, j, word, index + <span class="number">1</span>, visited) ||</span><br><span class="line">visitBoard(board, i, j + <span class="number">1</span>, word, index + <span class="number">1</span>, visited) ||</span><br><span class="line">visitBoard(board, i - <span class="number">1</span>, j, word, index + <span class="number">1</span>, visited) ||</span><br><span class="line">visitBoard(board, i, j - <span class="number">1</span>, word, index + <span class="number">1</span>, visited)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Go实现代码"><a href="#Go实现代码" class="headerlink" title="Go实现代码"></a>Go实现代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exist</span><span class="params">(board [][]<span class="keyword">byte</span>, word <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">visited := <span class="built_in">make</span>([][]<span class="keyword">bool</span>, <span class="built_in">len</span>(board))</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> board &#123;</span><br><span class="line">visited[i] = <span class="built_in">make</span>([]<span class="keyword">bool</span>,  <span class="built_in">len</span>(board[i]))</span><br><span class="line"><span class="keyword">for</span> j := <span class="keyword">range</span> board[i] &#123;</span><br><span class="line">visited[i][j] = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> board &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="keyword">range</span> board[i] &#123;</span><br><span class="line"><span class="keyword">if</span> visitBoard(board, i, j, word, <span class="number">0</span>, visited) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">visitBoard</span><span class="params">(board [][]<span class="keyword">byte</span>, i <span class="keyword">int</span>, j <span class="keyword">int</span>, word <span class="keyword">string</span>, index <span class="keyword">int</span>, visited [][]<span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> index &gt;= <span class="built_in">len</span>(word) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> i &lt; <span class="number">0</span> || i &gt;= <span class="built_in">len</span>(board) || j &lt; <span class="number">0</span> || j &gt;= <span class="built_in">len</span>(board[i]) || visited[i][j] &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> board[i][j] == word[index] &#123;</span><br><span class="line">visited[i][j] = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> visitBoard(board, i, j + <span class="number">1</span>, word, index + <span class="number">1</span>, visited) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> visitBoard(board, i + <span class="number">1</span>, j, word, index + <span class="number">1</span>, visited) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> visitBoard(board, i - <span class="number">1</span>, j, word, index + <span class="number">1</span>, visited) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> visitBoard(board, i, j - <span class="number">1</span>, word, index + <span class="number">1</span>, visited) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">visited[i][j] = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>940. Distinct Subsequences II</title>
      <link href="/2019/11/09/leetecode/940-Distinct-Subsequences-II/"/>
      <url>/2019/11/09/leetecode/940-Distinct-Subsequences-II/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个字符串S，求出它所有不重复的子串，子串不包含空串。<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>有好几种方法</p><h2 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h2><p>见<a href="https://www.jianshu.com/p/02501f516437" target="_blank" rel="noopener">lee_5a30</a>的解法。他用到一个int endsWith[26]数组，endsWith[i]来表示以第i个字母结束的子串的数量。算法复杂度为O(26N)。</p><h2 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h2><p>用dp[i]表示以S[i]结尾可以组成多少个子串。初始化dp[i]为1，表示只有包含单个字符S[i]的情况。如果S中一个重复的字符都没有，dp[i] = dp[0] + dp[1] + … + dp[i - 1]。假如S[i]在前最接近的字符S[j]与其相等，既S[i]==S[j]。那么从0~j-1组成的子串与S[j]组合而成的子串集合A，从0~j-1组成的子串与S[i]组合而成的子串集合B，两者是一样的。所以需要把这部分去除掉。所以当S[i] == S[j]的时候，dp[i] = dp[j] + dp[j + 1] + … + dp[i - 1] - 1。减一由于单个S[j]子串被重复计算，所以需要去除。最终结果就是dp[0] + dp[1] + … + dp[n - 1]。算法复杂度为O(n^2)</p><h2 id="第三种方法"><a href="#第三种方法" class="headerlink" title="第三种方法"></a>第三种方法</h2><p>第三种方法是题解给出的方法，思想和第二种类似，需要把重复的子串给去除掉。用dp[i]表示从0~i-1的S子串一共能够形成多少个不同的子串集合，其中也包含空串。很显然，初始dp[0]为2，子串集合为[“”, S[0]]。当0~i中没有出现重复的字符时候dp[i] = 2 * dp[i - 1]。因为0~i-1有dp[i - 1]种子串可能，由于没有重复字符，所以增加的S[i]可以拼接在每个0~i-1形成的子串集合元素后面而不会重复，形成子串集合，所以为dp[i - 1] + dp[i - 1]。当S[i]在0~i-1中有重复的时候，需要去除掉重复的这部分。<br><br>例如:S = “caba”。<br><br>dp[0] = 2, 集合为[“”, “c”]。<br><br>dp[1] = 4, 集合为[“”, “c”, “a”, “ca”]。<br><br>dp[2] = 8, 集合为[“”, “c”, “a”, “ca”, “b”, “cb”, “ab”, “cab”]。<br><br>当计算dp[3]时，S[3] == S[1],需要把计算dp[1]增加的集合[“a”, “ca”]去除掉，这部分是重复的。而这部分是通过dp[0]形成的[“”, “c”]与”a”拼接而成。因为字符串只有26个小写字母，所以用一个last[26]的数组来记录每个字符在S中的最新位置。所以当有重复的字符出现的时候，dp[i] = 2 * dp[i - 1[ - dp[last[S[i] - 1]。<br><br>最后返回的结果既为dp[n]，这个结果需要减一，表示去除空串。算法复杂度为O(n)。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="第一种方法的实现代码"><a href="#第一种方法的实现代码" class="headerlink" title="第一种方法的实现代码"></a>第一种方法的实现代码</h2><h3 id="C-实现代码"><a href="#C-实现代码" class="headerlink" title="C++实现代码"></a>C++实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">distinctSubseqII</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ends[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(ends, <span class="number">0</span>, <span class="keyword">sizeof</span>(ends));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++) &#123;</span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; k++) &#123;</span><br><span class="line">result += ends[k];</span><br><span class="line">&#125;</span><br><span class="line">ends[S[i] - <span class="string">'a'</span>] = (result + <span class="number">1</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; k++) &#123;</span><br><span class="line">result += ends[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>)(result % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="GO实现代码"><a href="#GO实现代码" class="headerlink" title="GO实现代码"></a>GO实现代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">distinctSubseqII</span><span class="params">(S <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">ends := <span class="built_in">make</span>([]<span class="keyword">int64</span>, <span class="number">26</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">26</span>; i++ &#123;</span><br><span class="line">ends[i] = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mod := <span class="keyword">int64</span>(<span class="number">1e9</span> + <span class="number">7</span>)</span><br><span class="line">result := <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>([]<span class="keyword">rune</span>(S)); i++ &#123;</span><br><span class="line">result = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="number">0</span>; k &lt; <span class="number">26</span>; k++ &#123;</span><br><span class="line">result += ends[k]</span><br><span class="line">&#125;</span><br><span class="line">ends[<span class="keyword">int</span>(S[i] - <span class="string">'a'</span>)] = (result + <span class="number">1</span>) % mod</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="number">0</span>; k &lt; <span class="number">26</span>; k++ &#123;</span><br><span class="line">result += ends[k]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int</span>(result % mod)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二种方法实现代码"><a href="#第二种方法实现代码" class="headerlink" title="第二种方法实现代码"></a>第二种方法实现代码</h2><h3 id="C-实现代码-1"><a href="#C-实现代码-1" class="headerlink" title="C++实现代码"></a>C++实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">distinctSubseqII</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line"> <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; dp(S.length());</span><br><span class="line"> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.size(); i++) &#123;</span><br><span class="line"> dp[i] = <span class="number">1L</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++) &#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line"> dp[i] += dp[j];</span><br><span class="line"> <span class="keyword">if</span>(S[i] == S[j]) &#123;</span><br><span class="line"> dp[i] -= <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> dp[i] = dp[i] % mod;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">long</span> result = <span class="number">0L</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.size(); i++) &#123;</span><br><span class="line"> result += dp[i];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> (<span class="keyword">int</span>)(result % mod);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="GO实现代码-1"><a href="#GO实现代码-1" class="headerlink" title="GO实现代码"></a>GO实现代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">distinctSubseqII</span><span class="params">(S <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="keyword">int64</span>, <span class="built_in">len</span>([]<span class="keyword">rune</span>(S)))</span><br><span class="line">mod := <span class="keyword">int64</span>(<span class="number">1e9</span> + <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(dp); i++ &#123;</span><br><span class="line">dp[i] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>([]<span class="keyword">rune</span>(S)); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j-- &#123;</span><br><span class="line">dp[i] += dp[j]</span><br><span class="line"><span class="keyword">if</span> S[i] == S[j] &#123;</span><br><span class="line">dp[i] -= <span class="number">1</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">dp[i] %= mod</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result := <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(dp); i++ &#123;</span><br><span class="line">result += dp[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int</span>(result % mod)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第三种方法实现代码"><a href="#第三种方法实现代码" class="headerlink" title="第三种方法实现代码"></a>第三种方法实现代码</h2><h3 id="C-实现代码-2"><a href="#C-实现代码-2" class="headerlink" title="C++实现代码"></a>C++实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">distinctSubseqII</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; dp(S.length());</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; last(<span class="number">26</span>);</span><br><span class="line"></span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; last.size(); i++) &#123;</span><br><span class="line">last[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = (<span class="keyword">int</span>)(S[<span class="number">0</span>] - <span class="string">'a'</span>);</span><br><span class="line">last[index] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; S.length(); i++) &#123;</span><br><span class="line">index = (<span class="keyword">int</span>)(S[i] - <span class="string">'a'</span>);</span><br><span class="line">dp[i] = <span class="number">2</span> * dp[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>(last[index] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> redundant = last[index] &gt; <span class="number">0</span> ? dp[last[index] - <span class="number">1</span>] : <span class="number">1</span>;</span><br><span class="line">dp[i] -= redundant;</span><br><span class="line">&#125;</span><br><span class="line">dp[i] %= mod;</span><br><span class="line">last[index] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n = S.length() - <span class="number">1</span>;</span><br><span class="line">dp[n] -= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(dp[n] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">dp[n] += mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="GO实现代码-2"><a href="#GO实现代码-2" class="headerlink" title="GO实现代码"></a>GO实现代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">distinctSubseqII</span><span class="params">(S <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>([]<span class="keyword">rune</span>(S))</span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="keyword">int64</span>, n)</span><br><span class="line">mod := <span class="keyword">int64</span>(<span class="number">1e9</span> + <span class="number">7</span>)</span><br><span class="line">last := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">26</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">26</span>; i++ &#123;</span><br><span class="line">last[i] = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line">index := <span class="keyword">int</span>(S[<span class="number">0</span>] - <span class="string">'a'</span>)</span><br><span class="line">last[index] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">dp[i] = <span class="number">2</span> * dp[i - <span class="number">1</span>]</span><br><span class="line">index = <span class="keyword">int</span>(S[i] - <span class="string">'a'</span>)</span><br><span class="line"><span class="keyword">if</span> last[index] &gt;= <span class="number">0</span> &#123;</span><br><span class="line">remain := <span class="keyword">int64</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> last[index] &gt; <span class="number">0</span> &#123;</span><br><span class="line">remain = dp[last[index] - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">dp[i] -= remain</span><br><span class="line">&#125;</span><br><span class="line">dp[i] %= mod</span><br><span class="line">last[index] = i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dp[n - <span class="number">1</span>] -= <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span>(dp[n - <span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">dp[n - <span class="number">1</span>] += mod</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int</span>(dp[n - <span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>115. Distinct Subsequences</title>
      <link href="/2019/11/09/leetecode/115-Distinct-Subsequences/"/>
      <url>/2019/11/09/leetecode/115-Distinct-Subsequences/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个母串S和子串T。要求出有S中有多少个子串能成为T,不能改变S中字符原有的顺序。也既在S中删除一些字符，能形成子串T有多少种方法。<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>跟最短编辑距离的思想有些类似。用dp[i][j]表示0~i-1的母串S，转成0~j-1子串T有多少种方法。初始的dp[i][0]为1，因为S变成空串只有1种方法。当S[i]不等于T[j]时候dp[i + 1][j + 1] = dp[i][j + 1],表示S新增加一个字符，没有能增加变换的可能性。当S[i]等于T[j]时候，dp[i + 1][j + 1] = dp[i][j + 1] + dp[i][j],由于S新增加了一个字符，导致在dp[i][j + 1]的基础上增加了一些可能性，由于S[i] == T[j]，这个增加的可能性就是0~i-1的母串S转化成0~j-1子串T有多少种方法，也既dp[i][j]。最后dp[S.length][T.length]就是最终的结果。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-实现代码"><a href="#C-实现代码" class="headerlink" title="C++实现代码"></a>C++实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s.empty()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t.empty()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> **data = <span class="keyword">new</span> <span class="keyword">long</span> <span class="keyword">long</span>*[s.length() + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() + <span class="number">1</span>; i++) &#123;</span><br><span class="line">data[i] = <span class="keyword">new</span> <span class="keyword">long</span> <span class="keyword">long</span>[t.length() + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">memset</span>(data[i], <span class="number">0</span>, (t.length() + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length() + <span class="number">1</span>; i++) &#123;</span><br><span class="line">data[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= t.length(); j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) &#123;</span><br><span class="line">data[i][j] = data[i - <span class="number">1</span>][j - <span class="number">1</span>] + data[i - <span class="number">1</span>][j];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">data[i][j] = data[i - <span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> result = (<span class="keyword">int</span>)data[s.length()][t.length()];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() + <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] data[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="go实现代码"><a href="#go实现代码" class="headerlink" title="go实现代码"></a>go实现代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numDistinct</span><span class="params">(s <span class="keyword">string</span>, t <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">slen := <span class="built_in">len</span>([]<span class="keyword">rune</span>(s))</span><br><span class="line">tlen := <span class="built_in">len</span>([]<span class="keyword">rune</span>(t))</span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="keyword">int64</span>, slen + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; slen + <span class="number">1</span>; i++ &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="keyword">int64</span>, tlen + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; slen + <span class="number">1</span>; i++ &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; slen; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; tlen; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> s[i] == t[j] &#123;</span><br><span class="line">dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j + <span class="number">1</span>] + dp[i][j]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j + <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int</span>(dp[slen][tlen])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>37. Sudoku Solver</title>
      <link href="/2019/11/08/leetecode/37-Sudoku-Solver/"/>
      <url>/2019/11/08/leetecode/37-Sudoku-Solver/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>这题是<a href="https://daxiaoluo.github.io/2019/11/08/leetecode/36-Valid-Sudoku/" target="_blank" rel="noopener">Valid Sudoku</a>的延伸。之前只需要判断当前填数字的9宫格是否符合标准。这里是要求把没有填的格子填上数字，使其符合9宫格的标准。<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>基本和之前的思路一样。用递归法，遍历每个格子，对于没有填写数字的格子，尝试用不同的数字填写，然后判断是否符合9宫格的标准。只有符合了才继续递归往下遍历。如果已经填写了，就直接判断。最后递归遍历完，就能输出符合标准的9宫格。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(row, <span class="number">0</span>, <span class="keyword">sizeof</span>(row));</span><br><span class="line"><span class="built_in">memset</span>(col, <span class="number">0</span>, <span class="keyword">sizeof</span>(col));</span><br><span class="line"><span class="built_in">memset</span>(cell, <span class="number">0</span>, <span class="keyword">sizeof</span>(cell));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(board[i][j] != <span class="string">'.'</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> b = board[i][j] - <span class="string">'0'</span>;</span><br><span class="line">fillMemory(i, j, b, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">resolve(board, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> row[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> col[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> cell[<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">resolve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i &gt;= <span class="number">9</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( j &gt;= <span class="number">9</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> resolve(board, i + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(board[i][j] != <span class="string">'.'</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> resolve(board, i, j + <span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">'1'</span>; c &lt;= <span class="string">'9'</span>; c++) &#123;</span><br><span class="line"><span class="keyword">int</span> b = c - <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span>(!isValid(i, j, b)) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">board[i][j] = c;</span><br><span class="line">fillMemory(i, j, b, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(resolve(board, i, j + <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">fillMemory(i, j, b, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fillMemory</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> b, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="comment">// fill row</span></span><br><span class="line"><span class="keyword">int</span> bit = i * <span class="number">9</span> + b;</span><br><span class="line">fill(row, bit, val);</span><br><span class="line"><span class="comment">// fill col</span></span><br><span class="line">bit = j * <span class="number">9</span> + b;</span><br><span class="line">fill(col, bit, val);</span><br><span class="line"><span class="comment">// fill cell</span></span><br><span class="line"><span class="keyword">int</span> cell_row = i / <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> cell_col = j / <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> cell_num = cell_row * <span class="number">3</span> + cell_col;</span><br><span class="line">bit = cell_num * <span class="number">9</span> + b;</span><br><span class="line">fill(cell, bit, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="comment">// check row</span></span><br><span class="line"><span class="keyword">int</span> bit = i * <span class="number">9</span> + b;</span><br><span class="line"><span class="keyword">if</span>(isFilled(row, bit)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check col</span></span><br><span class="line">bit = j * <span class="number">9</span> + b;</span><br><span class="line"><span class="keyword">if</span>(isFilled(col, bit)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// check cell</span></span><br><span class="line"><span class="keyword">int</span> cell_row = i / <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> cell_col = j / <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> cell_num = cell_row * <span class="number">3</span> + cell_col;</span><br><span class="line">bit = cell_num * <span class="number">9</span> + b;</span><br><span class="line"><span class="keyword">if</span>(isFilled(cell, bit)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isFilled</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = bit / <span class="number">32</span>;</span><br><span class="line"><span class="keyword">int</span> b = bit &amp; <span class="number">31</span>;</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">array</span>[index] &amp; (<span class="number">1</span> &lt;&lt; b)) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> bit, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = bit / <span class="number">32</span>;</span><br><span class="line"><span class="keyword">int</span> b = bit &amp; <span class="number">31</span>;</span><br><span class="line"><span class="keyword">if</span>(val &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">array</span>[index] |= (<span class="number">1</span> &lt;&lt; b);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">array</span>[index] &amp;= (<span class="number">-1</span> ^ (<span class="number">1</span> &lt;&lt; b));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Go实现代码"><a href="#Go实现代码" class="headerlink" title="Go实现代码"></a>Go实现代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">solveSudoku</span><span class="params">(board [][]<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">row := <span class="built_in">make</span>([]<span class="keyword">uint32</span>, <span class="number">3</span>)</span><br><span class="line">col := <span class="built_in">make</span>([]<span class="keyword">uint32</span>, <span class="number">3</span>)</span><br><span class="line">cell := <span class="built_in">make</span>([]<span class="keyword">uint32</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">zeroPad(row)</span><br><span class="line">zeroPad(col)</span><br><span class="line">zeroPad(cell)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> board &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="keyword">range</span> board[i] &#123;</span><br><span class="line"><span class="keyword">if</span> board[i][j] != <span class="string">'.'</span> &#123;</span><br><span class="line">b := <span class="keyword">int</span>(board[i][j] - <span class="string">'0'</span>)</span><br><span class="line">fillMemory(row, col, cell, i, j, b, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">resolve(board, row, col, cell, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resolve</span><span class="params">(board [][]<span class="keyword">byte</span>, row []<span class="keyword">uint32</span>, col []<span class="keyword">uint32</span>, cell []<span class="keyword">uint32</span>, i <span class="keyword">int</span>, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> i &gt;= <span class="number">9</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> j &gt;= <span class="number">9</span> &#123;</span><br><span class="line"><span class="keyword">return</span> resolve(board, row, col, cell, i + <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> board[i][j] != <span class="string">'.'</span> &#123;</span><br><span class="line"><span class="keyword">return</span> resolve(board, row, col, cell, i, j + <span class="number">1</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> c := <span class="string">'1'</span>; c &lt;= <span class="string">'9'</span>; c++ &#123;</span><br><span class="line">b := <span class="keyword">int</span>(c - <span class="string">'0'</span>)</span><br><span class="line"><span class="keyword">if</span> !isValid(row, col, cell, i, j, b) &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">board[i][j] = <span class="keyword">byte</span>(c)</span><br><span class="line">fillMemory(row, col, cell, i, j, b, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> resolve(board, row, col, cell, i, j + <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">board[i][j] = <span class="string">'.'</span></span><br><span class="line">fillMemory(row, col, cell, i, j, b, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fillMemory</span><span class="params">(row []<span class="keyword">uint32</span>, col []<span class="keyword">uint32</span>, cell []<span class="keyword">uint32</span>, i <span class="keyword">int</span>, j <span class="keyword">int</span>, b <span class="keyword">int</span>, val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// fill row</span></span><br><span class="line">bit := i * <span class="number">9</span> + b</span><br><span class="line">fill(row, bit, val)</span><br><span class="line"></span><br><span class="line"><span class="comment">// fill col</span></span><br><span class="line">bit = j * <span class="number">9</span> + b</span><br><span class="line">fill(col, bit, val)</span><br><span class="line"></span><br><span class="line"><span class="comment">// fill cell</span></span><br><span class="line">cell_row := i / <span class="number">3</span></span><br><span class="line">cell_col := j / <span class="number">3</span></span><br><span class="line">cell_num := cell_row * <span class="number">3</span> + cell_col</span><br><span class="line">bit = cell_num * <span class="number">9</span> + b</span><br><span class="line">fill(cell, bit, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(row []<span class="keyword">uint32</span>, col []<span class="keyword">uint32</span>, cell []<span class="keyword">uint32</span>, i <span class="keyword">int</span>, j <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// check row</span></span><br><span class="line">bit := i * <span class="number">9</span> + b</span><br><span class="line"><span class="keyword">if</span> isFilled(row, bit) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check col</span></span><br><span class="line">bit = j * <span class="number">9</span> + b</span><br><span class="line"><span class="keyword">if</span> isFilled(col, bit) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check cell</span></span><br><span class="line">cell_row := i / <span class="number">3</span></span><br><span class="line">cell_col := j / <span class="number">3</span></span><br><span class="line">cell_num := cell_row * <span class="number">3</span> + cell_col</span><br><span class="line">bit = cell_num * <span class="number">9</span> + b</span><br><span class="line"><span class="keyword">if</span> isFilled(cell, bit) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zeroPad</span><span class="params">(array []<span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> array &#123;</span><br><span class="line">array[i] = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fill</span><span class="params">(array []<span class="keyword">uint32</span>, bit <span class="keyword">int</span>, val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">index := bit / <span class="number">32</span></span><br><span class="line">b := <span class="keyword">uint</span>(bit &amp; <span class="number">31</span>)</span><br><span class="line"><span class="keyword">if</span> val &gt; <span class="number">0</span> &#123;</span><br><span class="line">array[index] |= (<span class="number">1</span> &lt;&lt; b)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">array[index] &amp;= (<span class="number">4294967295</span> ^ (<span class="number">1</span> &lt;&lt; b))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isFilled</span><span class="params">(array []<span class="keyword">uint32</span>, bit <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">index := bit / <span class="number">32</span></span><br><span class="line">b := <span class="keyword">uint</span>(bit &amp; <span class="number">31</span>)</span><br><span class="line"><span class="keyword">return</span> (array[index] &amp; (<span class="number">1</span> &lt;&lt; b)) != <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>36. Valid Sudoku</title>
      <link href="/2019/11/08/leetecode/36-Valid-Sudoku/"/>
      <url>/2019/11/08/leetecode/36-Valid-Sudoku/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>9宫格的判断。给你一个9*9的方格。要求你判断棋盘填的状态是否符合9宫格的标准。9宫格标准是橫竖都不能有重复的数字出现，并且3*3的小方格也不能有重复的数字出现。<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>简单题，遍历每个方格，如果是未数字的方格就忽略。如果填写了数字，判断橫向和纵向是否有重复的数字，并且判断所处的3*3的方格是否有重复的数字。没有记录其在横向，纵向和3*3的方格里，继续遍历。否则返回false。遍历完发现都符合标准，则返回true.</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> row[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> col[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> cell[<span class="number">3</span>];</span><br><span class="line"><span class="built_in">memset</span>(row, <span class="number">0</span>, <span class="keyword">sizeof</span>(row));</span><br><span class="line"><span class="built_in">memset</span>(col, <span class="number">0</span>, <span class="keyword">sizeof</span>(col));</span><br><span class="line"><span class="built_in">memset</span>(cell, <span class="number">0</span>, <span class="keyword">sizeof</span>(cell));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(board[i][j] == <span class="string">'.'</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num = board[i][j] - <span class="string">'0'</span>;</span><br><span class="line"><span class="comment">//check row</span></span><br><span class="line"><span class="keyword">int</span> bit = i * <span class="number">9</span> + num;</span><br><span class="line"><span class="keyword">if</span>(isFilled(row, bit)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">fill(row, bit);</span><br><span class="line"><span class="comment">//check column</span></span><br><span class="line">bit = j * <span class="number">9</span> + num;</span><br><span class="line"><span class="keyword">if</span>(isFilled(col, bit)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">fill(col, bit);</span><br><span class="line"><span class="comment">//check nine cell</span></span><br><span class="line"><span class="keyword">int</span> cellRow = i / <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> cellCol = j / <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> cellNum = cellRow * <span class="number">3</span> + cellCol;</span><br><span class="line">bit = cellNum * <span class="number">9</span> + num;</span><br><span class="line"><span class="keyword">if</span>(isFilled(cell, bit)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">fill(cell, bit);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = bit / <span class="number">32</span>;</span><br><span class="line"><span class="keyword">int</span> b = bit &amp; <span class="number">31</span>;</span><br><span class="line"><span class="built_in">array</span>[index] |= (<span class="number">1</span> &lt;&lt; b);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isFilled</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = bit / <span class="number">32</span>;</span><br><span class="line"><span class="keyword">int</span> b = bit &amp; <span class="number">31</span>;</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">array</span>[index] &amp; (<span class="number">1</span> &lt;&lt; b)) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="go代码实现"><a href="#go代码实现" class="headerlink" title="go代码实现"></a>go代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidSudoku</span><span class="params">(board [][]<span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">row := <span class="built_in">make</span>([]<span class="keyword">uint</span>, <span class="number">3</span>)</span><br><span class="line">col := <span class="built_in">make</span>([]<span class="keyword">uint</span>, <span class="number">3</span>)</span><br><span class="line">cell := <span class="built_in">make</span>([]<span class="keyword">uint</span>, <span class="number">3</span>)</span><br><span class="line">zeroPad(row)</span><br><span class="line">zeroPad(col)</span><br><span class="line">zeroPad(cell)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">9</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">9</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> board[i][j] == <span class="string">'.'</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">num := <span class="keyword">int</span>(board[i][j] - <span class="string">'0'</span>)</span><br><span class="line"><span class="comment">// check row</span></span><br><span class="line">bit := i * <span class="number">9</span> + num</span><br><span class="line"><span class="keyword">if</span> isFilled(row, bit) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">fill(row, bit)</span><br><span class="line"></span><br><span class="line"><span class="comment">// check col</span></span><br><span class="line">bit = j * <span class="number">9</span> + num</span><br><span class="line"><span class="keyword">if</span> isFilled(col, bit) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">fill(col, bit)</span><br><span class="line"></span><br><span class="line"><span class="comment">// check nine cell</span></span><br><span class="line">cell_row := i / <span class="number">3</span></span><br><span class="line">cell_col := j / <span class="number">3</span></span><br><span class="line">cell_num := cell_row * <span class="number">3</span> + cell_col</span><br><span class="line">bit = cell_num * <span class="number">9</span> + num</span><br><span class="line"><span class="keyword">if</span> isFilled(cell, bit) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">fill(cell, bit)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zeroPad</span><span class="params">(array []<span class="keyword">uint</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> array &#123;</span><br><span class="line">array[i] = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fill</span><span class="params">(array []<span class="keyword">uint</span>, bit <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">index := bit / <span class="number">32</span></span><br><span class="line">b := <span class="keyword">uint</span>(bit &amp; <span class="number">31</span>)</span><br><span class="line">array[index] |= (<span class="number">1</span> &lt;&lt; b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isFilled</span><span class="params">(array []<span class="keyword">uint</span>, bit <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">index := bit / <span class="number">32</span></span><br><span class="line">b := <span class="keyword">uint</span>(bit &amp; <span class="number">31</span>)</span><br><span class="line"><span class="keyword">return</span> (array[index] &amp; (<span class="number">1</span> &lt;&lt; b)) != <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ZigZag Conversion</title>
      <link href="/2017/01/03/leetecode/ZigZag-Conversion/"/>
      <url>/2017/01/03/leetecode/ZigZag-Conversion/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个数组和这个数组的行数，这个数组是按照纵向的Z的形状排列的。<br>例如字符串”PAYPALISHIRING”,行数为3。排列形状入下图所示：<br><img src="/images/leetecode/ZigZag-Conversion.png" alt="ZigZag Conversion Picture 1"><br>输出需要按行从左向右输出,结果为”PAHNPLSIIGYIR”。<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p><img src="/images/leetecode/ZigZag-Conversion-2.png" alt="ZigZag Conversion Picture 2"><br>如上图所示，同一行两列的两个字符a和b在Z字形字符串的间隔为X + Y + Z这3个区段所包含的字符个数。<br>其中Z区段包含的字符个数为行数(n + 1)减去2，X和Y区段包含的字符数为行数(n + 1)，<br>所以总的间隔数为2 <em> (n + 1) - 2。<br>同理可以分析出c和d的间隔数一样为2 </em> (n + 1) - 2。<br>若如上图中，求a和c字符的字符间距为a和b的字符间距减去M和N包含的区段。<br>所以a和c的字符间距为2 <em> (n + 1) - 2 - 2 </em> i。<br>综上所述，在输出第0行和最后一行每个字符时，只需要在上一列的基础上加上列间距既可以在Z字形字符串<br>找到对应的字符。对于中间行，要分2种情况去处理，对于当前输出的是在Z字形的列上面的字符时，只需在<br>上一列的基础上加上列间距就可以找到。对于当前要输出的是在Z字形夹在中间的字符时,需要下一列同一行的位置<br>减去2 * 当前所处的行号。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> gap = <span class="number">2</span> * numRows - <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">string</span> result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; s.size(); j += gap) &#123;</span><br><span class="line">                result += s[j];</span><br><span class="line">                <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; i != numRows - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> index = j + gap - <span class="number">2</span> * i;</span><br><span class="line">                    <span class="keyword">if</span>(index &lt; s.size()) result += s[index];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Go实现"><a href="#Go实现" class="headerlink" title="Go实现"></a>Go实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convert</span><span class="params">(s <span class="keyword">string</span>, numRows <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">     <span class="keyword">if</span> numRows == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> result <span class="keyword">string</span></span><br><span class="line">    gap := <span class="number">2</span>*numRows - <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numRows; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i; j &lt; <span class="built_in">len</span>(s); j += gap &#123;</span><br><span class="line">            result += <span class="keyword">string</span>(s[j])</span><br><span class="line">            index := j + gap - <span class="number">2</span>*i</span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span> &amp;&amp; i != numRows<span class="number">-1</span> &amp;&amp; index &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">                result += <span class="keyword">string</span>(s[index])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Longest Palindromic Substring</title>
      <link href="/2017/01/03/leetecode/Longest-Palindromic-Substring/"/>
      <url>/2017/01/03/leetecode/Longest-Palindromic-Substring/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个字符串，要你求出这个字符串的最长回文串。<br>例如字符串”babad”,最长回文子串为”bab”或者”aba”。<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>最简单的方法，对于长度为奇数的回文串，我们以中轴往左右扩展i。对于长度为偶数的回文串，我们首先要判断中间2个字符是否相等，<br>若相等，则继续往左右两端进行扩展。这种方法的复杂度为O(n^2)。可以用另外一种方法，复杂度为O(n)。<br>上述的方法，由于有奇数长度的回文串和偶数长度的回文串的情况，所以每扫描到一个字符就要按这2种情况进行判断。<br>我们可以在字符串中间插入不会出现的字符，将其转化为一个奇数长度的回文串，待求出后再将这些多余的字符去掉。<br>例如字符串”babad”可以转化为”#b#a#b#a#d#”,这样子串的回文性也没有被破坏。<br>而且每次扩展新的回文串时，我们可以利用已经扫描过的回文信息。<br>利用数组handle来记录从当前这个位置到达最远的回文串的半径。例如字符串”#b#a#b#a#d#”, handle[3]=4。<br>用mx来记录当前回文串能延伸的最右边的位置。<br>如下图所示：<br><img src="/images/leetecode/Longest-Palindromic-Substring.png" alt="Longest Palindromic Substring"></p><p>如上图(a)所示，mx是当前所求到的回文串能延伸到最右边的位置。p是mx对应的中轴。<br>假如当前扫描到i位置，i在p的回文半径之内。可以利用已求出的各个位置的回文半径来求i的回文半径。<br>i关于p的对称点为j。若j的回文半径小于等于p的回文半径，由于被p的回文半径覆盖，根据对称性，<br>i位置左右两边handle[j]长度必然对称。所以求i的回文半径，可以在handle[j]的长度上也即使handle[i]=handle[j],<br>再在这个长度上往左右两边继续扩展直到碰到不相等的字符为止，最后得到handle[i]。<br>若j位置的回文半径向左超出了p的回文半径，如上图(b)所示，那么由于超出的部分不在p回文半径涵盖的范围内，没有对称性。<br>所以求handle[i]时，只能在mx - i的长度下继续向左右两边扩展。<br>若i不在p的回文半径之内，那么只有从左右两边一个个的比较来求得handel[i]。<br>为了让字符串左右扫描能够结束，处理过的字符串前面再加上一个不可能出现的字符”$”。  </p><p>在求完handle数组后，扫描这个数组，得到最大的回文半径max_length和与之对应的中轴位置max_index。<br>中轴对应的位置可能是原字符也有可能是”#”字符。若是原字符，说明回文串是个奇数长度。若是”#”字符，<br>说明回文串是个偶数长度。<br>max_index - max_length是以max_index为中轴向左延伸的位置，且这个位置字符必然为”#”。由于处理后的字符串<br>每个字符前面都有一个”#”字符，并且第0个字符是”$”，”$”可以与max_index - max_length对应的字符”#”对应。<br>所以这个回文串在原来的字符串的起始位置为(max_index - max_length) / 2，长度为max_length。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(s.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">            <span class="function"><span class="built_in">string</span> <span class="title">ss</span><span class="params">(<span class="string">"$"</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">string</span>::iterator it = s.begin(); it != s.end(); it++) &#123;</span><br><span class="line">                ss += <span class="string">"#"</span>;</span><br><span class="line">                ss += *it;</span><br><span class="line">            &#125;</span><br><span class="line">            ss += <span class="string">"#"</span>;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; handle(ss.size(), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ss.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = <span class="number">2</span> * p - i;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; mx) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(mx - i &gt; handle[j]) handle[i] = handle[j];</span><br><span class="line">                    <span class="keyword">else</span> handle[i] = mx - i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(ss[i + handle[i] + <span class="number">1</span>] == ss[i - handle[i] - <span class="number">1</span>]) handle[i]++;</span><br><span class="line">                <span class="keyword">if</span>(mx &lt; i + handle[i]) &#123;</span><br><span class="line">                    mx = i + handle[i];</span><br><span class="line">                    p = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; handle.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(length &lt; handle[i]) &#123;</span><br><span class="line">                    index = i;</span><br><span class="line">                    length = handle[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> start_index = (index - length) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> s.substr(start_index, length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Go实现"><a href="#Go实现" class="headerlink" title="Go实现"></a>Go实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">       <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assist_str := <span class="string">"$"</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        assist_str += <span class="string">"#"</span></span><br><span class="line">        assist_str += <span class="keyword">string</span>(s[i])</span><br><span class="line">    &#125;</span><br><span class="line">    assist_str += <span class="string">"#"</span></span><br><span class="line"></span><br><span class="line">    handle := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(assist_str), <span class="built_in">len</span>(assist_str))</span><br><span class="line">    handle[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    mx := <span class="number">0</span></span><br><span class="line">    id := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(assist_str); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> mx &lt;= i &#123;</span><br><span class="line">            handle[i] = <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j := <span class="number">2</span>*id - i</span><br><span class="line">            <span class="keyword">if</span> mx-i &gt; handle[j] &#123;</span><br><span class="line">                handle[i] = handle[j]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handle[i] = mx - i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i+handle[i]+<span class="number">1</span> &lt; <span class="built_in">len</span>(assist_str) &amp;&amp; i-handle[i]<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; assist_str[i+handle[i]+<span class="number">1</span>] == assist_str[i-handle[i]<span class="number">-1</span>] &#123;</span><br><span class="line">            handle[i] += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> mx &lt; i+handle[i] &#123;</span><br><span class="line">            id = i</span><br><span class="line">            mx = i + handle[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mx_index := <span class="number">0</span></span><br><span class="line">    mx_handle := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(handle); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> handle[i] &gt; mx_handle &#123;</span><br><span class="line">            mx_index = i</span><br><span class="line">            mx_handle = handle[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    start_index := (mx_index - mx_handle) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> s[start_index:start_index + mx_handle]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Median of Two Sorted Arrays</title>
      <link href="/2016/10/24/leetecode/Median-of-Two-Sorted-Arrays/"/>
      <url>/2016/10/24/leetecode/Median-of-Two-Sorted-Arrays/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>题目可以转换为2个数组长度和为k,当这个k为奇数时，求第k/2小的数（从0开始数）。<br>若k为偶数，求出第k/2 - 1小的数和第k/2小的数的平均值。</p><p>给定两个从小到大排序好的整数数组。要求你求出这两个数的中位数。<br>例如：<br>nums1 = [1, 3]<br>nums2 = [2]<br>它们的中位数为2.0</p><p>nums1 = [1, 2]<br>nums2 = [3, 4]<br>它们的中位数为(2 + 3)/2 = 2.5<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>最简单的方式是用归并排序将2个有序数组合并成一个有序数据，然后就可以求出这两个数组的中位数。算法复杂度为O(n)。<br>我们还有另一种方法求解，2个数组都是有序的，可以利用折半查找的方式来求这两个数组的中位数，也即转而求这两个数组<br>第k小的数，即能求出中位数。算法复杂度为O(log(n))。<br>假设有两个排序好的数组nums1和nums2,分别如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums1[0], nums1[1], ... , nums1[m/2], nums1[m/2 + 1], ... , nums1[m - 1]  </span><br><span class="line">nums2[0], nums2[1], ... , nums2[n/2], nums2[n/2 + 1], ... , nums2[n - 1]</span><br></pre></td></tr></table></figure></p><ol><li>若nums1[m/2] &gt;= nums2[n/2], 并且nums1数组[0, m/2 - 1]范围的整数个数与nums2数组[0, n/2]范围的整数个数的总和大于等于k时。<br>由于nums1[m/2] &gt;= nums2[n/2]，所以nums1数组[m/2, m-1]这个范围的数，必然会比nums1数组[0, m/2 - 1]和nums2数组[0, n/2]范围的数大。<br>又由于nums1数组[0, m/2 - 1]范围的整数个数与nums2数组[0, n/2]范围的整数个数的总和大于等于k，所以第k小的数不可能会出现在nums1数组的[m/2, m -1]这个范围内，所以将[m/2, m -1]丢弃。  </li><li>若nums2[n/2] &gt;= nums1[m/2], 并且nums1数组[0, m/2]与nums2数组[0, n/2 - 1]包含的整数个数大于等于k时，分析方法和上述1类似，丢弃[n/2, n - 1]。  </li><li>若nums1[m/2] &gt;= nums2[n/2]，并且nums1数组[0, m/2 - 1]与nums2数组[0, n/2]范围的整数个数和小于k时。<br>由于nums2数组[0, n/2]范围的数小于nums1数组[m/2, m-1]和nums2数组[n/2 + 1, n - 1]这两个范围的数，<br>所以第k小的数不可能出现在nums2数组[0, n/2]范围内，所以抛弃[0, n/2]，转而求第k - (n/2 + 1)小的数。    </li><li>若nums2[n/2] &gt;= nums1[m/2], 并且nums1数组[0, m/2]与nums2数组[0, n/2 - 1]包含的整数个数小于k时。<br>方法与上述3类似，丢弃[0, m/2], 转而求第k - (m/2 + 1)小的数。  </li></ol><p>在剩余的数组中反复用上述的4个方法进行淘汰，知道其中一个数组被淘汰光，或者最后只剩下求第1小的数为止。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> total_len = nums1.size() + nums2.size();</span><br><span class="line">            <span class="keyword">if</span>((total_len &amp; <span class="number">1</span>) == <span class="number">1</span>) <span class="keyword">return</span> findTheKthMin(nums1, nums2, total_len / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> (findTheKthMin(nums1, nums2, total_len / <span class="number">2</span>) + findTheKthMin(nums1, nums2, total_len / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">findTheKthMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> high1 = nums1.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> low1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> high2 = nums2.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> low2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> mid1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> mid2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(low1 &lt;= high1 &amp;&amp; low2 &lt;= high2 &amp;&amp; k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                mid1 = (high1 + low1) / <span class="number">2</span>;</span><br><span class="line">                mid2 = (high2 + low2) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(mid1 - low1 + mid2 - low2 + <span class="number">1</span> &gt;= k) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums1[mid1] &gt;= nums2[mid2]) &#123;</span><br><span class="line">                        high1 = mid1 - <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        high2 = mid2 - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums1[mid1] &gt;= nums2[mid2]) &#123;</span><br><span class="line">                        k -= (mid2 - low2 + <span class="number">1</span>);</span><br><span class="line">                        low2 = mid2 + <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        k -= (mid1 - low1 + <span class="number">1</span>);</span><br><span class="line">                        low1 = mid1 + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(low1 &gt; high1) <span class="keyword">return</span> nums2[low2 + k - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(low2 &gt; high2) <span class="keyword">return</span> nums1[low1 + k - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> min(nums1[low1], nums2[low2]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Go实现"><a href="#Go实现" class="headerlink" title="Go实现"></a>Go实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    low_1 := <span class="number">0</span></span><br><span class="line">    high_1 := <span class="built_in">len</span>(nums1) - <span class="number">1</span></span><br><span class="line">    low_2 := <span class="number">0</span></span><br><span class="line">    high_2 := <span class="built_in">len</span>(nums2) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> low_1 &lt;= high_1 &amp;&amp; low_2 &lt;= high_2 &amp;&amp; k &gt; <span class="number">1</span> &#123;</span><br><span class="line">        mid_1 := (high_1 + low_1) / <span class="number">2</span></span><br><span class="line">        mid_2 := (high_2 + low_2) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> mid_1 - low_1 + mid_2 - low_2 + <span class="number">1</span> &gt;= k &#123;</span><br><span class="line">            <span class="keyword">if</span> nums1[mid_1] &gt;= nums2[mid_2] &#123;</span><br><span class="line">                high_1 = mid_1 - <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high_2 = mid_2 - <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> nums1[mid_1] &gt;= nums2[mid_2] &#123;</span><br><span class="line">                k -= (mid_2 - low_2 + <span class="number">1</span>)</span><br><span class="line">                low_2 = mid_2 + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= (mid_1 - low_1 + <span class="number">1</span>)</span><br><span class="line">                low_1 = mid_1 + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> low_1 &gt; high_1 &#123;</span><br><span class="line">        <span class="keyword">return</span> nums2[low_2 + k - <span class="number">1</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> low_2 &gt; high_2 &#123;</span><br><span class="line">        <span class="keyword">return</span> nums1[low_1 + k - <span class="number">1</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> nums1[low_1] &lt;= nums2[low_2] &#123;</span><br><span class="line">            <span class="keyword">return</span> nums1[low_1]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nums2[low_2]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    total_len := <span class="built_in">len</span>(nums1) + <span class="built_in">len</span>(nums2)</span><br><span class="line">    <span class="keyword">if</span> (total_len &amp; <span class="number">1</span>) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(findKthSortedArrays(nums1, nums2, total_len / <span class="number">2</span> + <span class="number">1</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">float64</span>(findKthSortedArrays(nums1, nums2, total_len/<span class="number">2</span>)) + <span class="keyword">float64</span>(findKthSortedArrays(nums1, nums2, total_len/<span class="number">2</span>+<span class="number">1</span>))) / <span class="number">2.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Longest Substring Without Repeating Characters</title>
      <link href="/2016/10/23/leetecode/Longest-Substring-Without-Repeating-Characters/"/>
      <url>/2016/10/23/leetecode/Longest-Substring-Without-Repeating-Characters/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个字符串，要你在这个字符串中求出最长的且里面没有重复的字符的子串。<br>例如：<br>字符串”abcabcbb”的不重复子串为”abc”。<br>字符串”bbbbb”的不重复子串为”b”。<br>字符串”pwwkew”的不重复子串为”wke”。<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>从头到尾遍历字符串，同时在遍历的过程中，用一个hash table来保存当前字符串的位置。<br>那么当扫描到的字符在hash table中存在，hash table对应的值就是最近出现的相同字符。<br>算出这个区间的子字符串的长度，保留符合条件的最长子字符串。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; hash_table;</span><br><span class="line"><span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> pre_index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">string</span>::iterator it = s.begin(); it != s.end(); it++) &#123;</span><br><span class="line"><span class="keyword">if</span>(hash_table.find(*it) != hash_table.end() &amp;&amp; pre_index &lt; hash_table[*it] + <span class="number">1</span>) &#123;</span><br><span class="line">pre_index = hash_table[*it] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">hash_table[*it] = index;</span><br><span class="line">max_len = max(max_len, index - pre_index + <span class="number">1</span>);</span><br><span class="line">index += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max_len;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Solution s;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.lengthOfLongestSubstring(<span class="string">"abba"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go实现"><a href="#Go实现" class="headerlink" title="Go实现"></a>Go实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Max</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">hash_table := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">rune</span>]<span class="keyword">int</span>)</span><br><span class="line">pre_index := <span class="number">0</span></span><br><span class="line">max_len := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i, c_str := <span class="keyword">range</span> s &#123;</span><br><span class="line">_, ok := hash_table[c_str]</span><br><span class="line"><span class="keyword">if</span> ok &amp;&amp; pre_index &lt; hash_table[c_str]+<span class="number">1</span> &#123;</span><br><span class="line">pre_index = hash_table[c_str] + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">hash_table[c_str] = i</span><br><span class="line">max_len = Max(max_len, (i - pre_index + <span class="number">1</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max_len</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Add Two Numbers</title>
      <link href="/2016/10/23/leetecode/Add-Two-Numbers/"/>
      <url>/2016/10/23/leetecode/Add-Two-Numbers/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定2个链表，链表中每个元素表示一个个位数，要求讲两个链表相加，<br>最后得到它们的结果<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>简单的进位相加。两个指针分别指向这两个链表，相加后若大于等于10，表示有进位，<br>保留，然后加到后面两个整数和中。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">ListNode *next;</span><br><span class="line">ListNode(<span class="keyword">int</span> x): val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode *<span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">ListNode *head = <span class="literal">NULL</span>;</span><br><span class="line">ListNode *pre = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> acc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = l1-&gt;val + l2-&gt;val + acc;</span><br><span class="line">ListNode *cur = <span class="keyword">new</span> ListNode(temp % <span class="number">10</span>);</span><br><span class="line">acc = temp / <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(head == <span class="literal">NULL</span>) head = cur;</span><br><span class="line"><span class="keyword">if</span>(pre != <span class="literal">NULL</span>) pre-&gt;next = cur; </span><br><span class="line">pre = cur;</span><br><span class="line">l1 = l1-&gt;next;</span><br><span class="line">l2 = l2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(l1 != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = l1-&gt;val + acc;</span><br><span class="line">ListNode *cur = <span class="keyword">new</span> ListNode(temp % <span class="number">10</span>);</span><br><span class="line">acc = temp / <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(head == <span class="literal">NULL</span>) head = cur;</span><br><span class="line"><span class="keyword">if</span>(pre != <span class="literal">NULL</span>) pre-&gt;next = cur;</span><br><span class="line">pre = cur;</span><br><span class="line">l1 = l1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(l2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = l2-&gt;val + acc;</span><br><span class="line">ListNode *cur = <span class="keyword">new</span> ListNode(temp % <span class="number">10</span>);</span><br><span class="line">acc = temp / <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(head == <span class="literal">NULL</span>) head = cur;</span><br><span class="line"><span class="keyword">if</span>(pre != <span class="literal">NULL</span>) pre-&gt;next = cur;</span><br><span class="line">pre = cur;</span><br><span class="line">l2 = l2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(acc &gt; <span class="number">0</span>) &#123;</span><br><span class="line">ListNode *cur = <span class="keyword">new</span> ListNode(acc);</span><br><span class="line"><span class="keyword">if</span>(head == <span class="literal">NULL</span>) head = cur;</span><br><span class="line"><span class="keyword">if</span>(pre != <span class="literal">NULL</span>) pre-&gt;next = cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Go实现"><a href="#Go实现" class="headerlink" title="Go实现"></a>Go实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">Val  <span class="keyword">int</span></span><br><span class="line">Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> head *ListNode = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">var</span> pre *ListNode = <span class="literal">nil</span></span><br><span class="line">acc := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">temp := l1.Val + l2.Val + acc</span><br><span class="line">cur := &amp;ListNode&#123;temp % <span class="number">10</span>, <span class="literal">nil</span>&#125;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">head = cur</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> pre != <span class="literal">nil</span> &#123;</span><br><span class="line">pre.Next = cur</span><br><span class="line">&#125;</span><br><span class="line">acc = temp / <span class="number">10</span></span><br><span class="line">pre = cur</span><br><span class="line">l2 = l2.Next</span><br><span class="line">l1 = l1.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">temp := l1.Val + acc</span><br><span class="line">cur := &amp;ListNode&#123;temp % <span class="number">10</span>, <span class="literal">nil</span>&#125;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">head = cur</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> pre != <span class="literal">nil</span> &#123;</span><br><span class="line">pre.Next = cur</span><br><span class="line">&#125;</span><br><span class="line">acc = temp / <span class="number">10</span></span><br><span class="line">pre = cur</span><br><span class="line">l1 = l1.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">temp := l2.Val + acc</span><br><span class="line">cur := &amp;ListNode&#123;temp % <span class="number">10</span>, <span class="literal">nil</span>&#125;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">head = cur</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> pre != <span class="literal">nil</span> &#123;</span><br><span class="line">pre.Next = cur</span><br><span class="line">&#125;</span><br><span class="line">acc = temp / <span class="number">10</span></span><br><span class="line">pre = cur</span><br><span class="line">l2 = l2.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> acc &gt; <span class="number">0</span> &#123;</span><br><span class="line">cur := &amp;ListNode&#123;acc, <span class="literal">nil</span>&#125;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">head = cur</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> pre != <span class="literal">nil</span> &#123;</span><br><span class="line">pre.Next = cur</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Two Sum</title>
      <link href="/2016/10/23/leetecode/Two-Sum/"/>
      <url>/2016/10/23/leetecode/Two-Sum/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个整数数组，比如nums = [2, 7, 11, 15]，和一个目标数，比如9。<br>要求你在这个数组中找到两个数，这两个数的和正好等于目标数，并且把这两个数的数组位置输出。<br>假设这个数组里面一定存在和等于目标数的两个数，并且这样的组合只存在唯一一个。<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>用一个结构来记录这个数组的值和位置组成一个新的数组。然后对这个数组进行重小到大的排序。<br>然后用两个指针a,b分别指向这个排序好的数组的首尾。若当前指向的两个数的和小于目标数，则<br>首指针a后移。若当前指向的两个数的和大于目标数，则尾指针b前移。若相等则输出这两个数在原<br>数组的位置。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> index;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">Node(<span class="keyword">int</span> index, <span class="keyword">int</span> v): index(index), val(v) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Node &amp;node1, <span class="keyword">const</span> Node &amp;node2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> node1.val &lt; node2.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; v;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">v.push_back(Node(i, nums[i]));</span><br><span class="line">&#125;</span><br><span class="line">sort(v.begin(), v.end(), compare);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = v.size() - <span class="number">1</span>; i &lt; j;) &#123;</span><br><span class="line"><span class="keyword">if</span>(v[i].val + v[j].val == target) &#123;</span><br><span class="line">result[<span class="number">0</span>] = v[i].index;</span><br><span class="line">result[<span class="number">1</span>] = v[j].index;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(v[i].val + v[j].val &gt; target) &#123;</span><br><span class="line">j--;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Go实现"><a href="#Go实现" class="headerlink" title="Go实现"></a>Go实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">index, val <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ByVal []Node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByVal)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(a) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByVal)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; a[i], a[j] = a[j], a[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByVal)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i].val &lt; a[j].val &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> nodes []Node</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">nodes = <span class="built_in">append</span>(nodes, Node&#123;i, nums[i]&#125;)</span><br><span class="line">&#125;</span><br><span class="line">sort.Sort(ByVal(nodes))</span><br><span class="line">results := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(nodes)<span class="number">-1</span>; i &lt; j; &#123;</span><br><span class="line">temp := nodes[i].val + nodes[j].val</span><br><span class="line"><span class="keyword">if</span> temp == target &#123;</span><br><span class="line">results[<span class="number">0</span>] = nodes[i].index</span><br><span class="line">results[<span class="number">1</span>] = nodes[j].index</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> temp &gt; target &#123;</span><br><span class="line">j--</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
